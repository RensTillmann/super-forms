"use strict"; // Minimize mutable state :)

/*! fast-json-patch, version: 2.0.7 */
var jsonpatch=function(a){function b(d){if(c[d])return c[d].exports;var e=c[d]={i:d,l:!1,exports:{}};return a[d].call(e.exports,e,e.exports,b),e.l=!0,e.exports}var c={};return b.m=a,b.c=c,b.i=function(a){return a},b.d=function(a,c,d){b.o(a,c)||Object.defineProperty(a,c,{configurable:!1,enumerable:!0,get:d})},b.n=function(a){var c=a&&a.__esModule?function(){return a['default']}:function(){return a};return b.d(c,'a',c),c},b.o=function(a,b){return Object.prototype.hasOwnProperty.call(a,b)},b.p='',b(b.s=3)}([function(a,b){function c(a,b){return i.call(a,b)}function d(a){if(Array.isArray(a)){for(var b=Array(a.length),d=0;d<b.length;d++)b[d]=''+d;return b}if(Object.keys)return Object.keys(a);var b=[];for(var e in a)c(a,e)&&b.push(e);return b}function e(a){return-1===a.indexOf('/')&&-1===a.indexOf('~')?a:a.replace(/~/g,'~0').replace(/\//g,'~1')}function f(a,b){var d;for(var g in a)if(c(a,g)){if(a[g]===b)return e(g)+'/';if('object'==typeof a[g]&&(d=f(a[g],b),''!=d))return e(g)+'/'+d}return''}function g(a){if(a===void 0)return!0;if(a)if(Array.isArray(a)){for(var b=0,c=a.length;b<c;b++)if(g(a[b]))return!0;}else if('object'==typeof a)for(var e=d(a),f=e.length,b=0;b<f;b++)if(g(a[e[b]]))return!0;return!1}var h=this&&this.__extends||function(a,c){function b(){this.constructor=a}for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d]);a.prototype=null===c?Object.create(c):(b.prototype=c.prototype,new b)},i=Object.prototype.hasOwnProperty;b.hasOwnProperty=c,b._objectKeys=d;b._deepClone=function(a){switch(typeof a){case'object':return JSON.parse(JSON.stringify(a));case'undefined':return null;default:return a;}},b.isInteger=function(a){for(var b,c=0,d=a.length;c<d;){if(b=a.charCodeAt(c),48<=b&&57>=b){c++;continue}return!1}return!0},b.escapePathComponent=e,b.unescapePathComponent=function(a){return a.replace(/~1/g,'/').replace(/~0/g,'~')},b._getPathRecursive=f,b.getPath=function(a,b){if(a===b)return'/';var c=f(a,b);if(''===c)throw new Error('Object not found in root');return'/'+c},b.hasUndefined=g;var j=function(a){function b(b,c,d,e,f){a.call(this,b),this.message=b,this.name=c,this.index=d,this.operation=e,this.tree=f}return h(b,a),b}(Error);b.PatchError=j},function(a,b,c){function d(a,b){if(''==b)return a;var c={op:'_get',path:b};return e(a,c),c.value}function e(a,c,e,f){if(void 0===e&&(e=!1),void 0===f&&(f=!0),e&&('function'==typeof e?e(c,0,a,c.path):g(c,0)),''===c.path){var h={newDocument:a};if('add'===c.op)return h.newDocument=c.value,h;if('replace'===c.op)return h.newDocument=c.value,h.removed=a,h;if('move'===c.op||'copy'===c.op)return h.newDocument=d(a,c.from),'move'===c.op&&(h.removed=a),h;if('test'===c.op){if(h.test=k(a,c.value),!1===h.test)throw new b.JsonPatchError('Test operation failed','TEST_OPERATION_FAILED',0,c,a);return h.newDocument=a,h}if('remove'===c.op)return h.removed=a,h.newDocument=null,h;if('_get'===c.op)return c.value=a,h;if(e)throw new b.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902','OPERATION_OP_INVALID',0,c,a);else return h}else{f||(a=l._deepClone(a));var i,j,o,p=c.path||'',q=p.split('/'),r=a,s=1,t=q.length;for(o='function'==typeof e?e:g;;){if(j=q[s],e&&void 0==i&&(void 0===r[j]?i=q.slice(0,s).join('/'):s==t-1&&(i=c.path),void 0!==i&&o(c,0,a,i)),s++,Array.isArray(r)){if('-'===j)j=r.length;else if(e&&!l.isInteger(j))throw new b.JsonPatchError('Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index','OPERATION_PATH_ILLEGAL_ARRAY_INDEX',0,c.path,c);else l.isInteger(j)&&(j=~~j);if(s>=t){if(e&&'add'===c.op&&j>r.length)throw new b.JsonPatchError('The specified index MUST NOT be greater than the number of elements in the array','OPERATION_VALUE_OUT_OF_BOUNDS',0,c.path,c);var h=n[c.op].call(c,r,j,a);if(!1===h.test)throw new b.JsonPatchError('Test operation failed','TEST_OPERATION_FAILED',0,c,a);return h}}else if(j&&-1!=j.indexOf('~')&&(j=l.unescapePathComponent(j)),s>=t){var h=m[c.op].call(c,r,j,a);if(!1===h.test)throw new b.JsonPatchError('Test operation failed','TEST_OPERATION_FAILED',0,c,a);return h}r=r[j]}}}function f(a,c,d,f){if(void 0===f&&(f=!0),d&&!Array.isArray(c))throw new b.JsonPatchError('Patch sequence must be an array','SEQUENCE_NOT_AN_ARRAY');f||(a=l._deepClone(a));for(var g=Array(c.length),h=0,i=c.length;h<i;h++)g[h]=e(a,c[h],d),a=g[h].newDocument;return g.newDocument=a,g}function g(a,c,d,e){if('object'!=typeof a||null===a||Array.isArray(a))throw new b.JsonPatchError('Operation is not an object','OPERATION_NOT_AN_OBJECT',c,a,d);else if(!m[a.op])throw new b.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902','OPERATION_OP_INVALID',c,a,d);else if('string'!=typeof a.path)throw new b.JsonPatchError('Operation `path` property is not a string','OPERATION_PATH_INVALID',c,a,d);else if(0!==a.path.indexOf('/')&&0<a.path.length)throw new b.JsonPatchError('Operation `path` property must start with "/"','OPERATION_PATH_INVALID',c,a,d);else if(('move'===a.op||'copy'===a.op)&&'string'!=typeof a.from)throw new b.JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)','OPERATION_FROM_REQUIRED',c,a,d);else if(('add'===a.op||'replace'===a.op||'test'===a.op)&&a.value===void 0)throw new b.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)','OPERATION_VALUE_REQUIRED',c,a,d);else if(('add'===a.op||'replace'===a.op||'test'===a.op)&&l.hasUndefined(a.value))throw new b.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)','OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED',c,a,d);else if(d)if('add'==a.op){var f=a.path.split('/').length,g=e.split('/').length;if(f!==g+1&&f!==g)throw new b.JsonPatchError('Cannot perform an `add` operation at the desired path','OPERATION_PATH_CANNOT_ADD',c,a,d)}else if('replace'===a.op||'remove'===a.op||'_get'===a.op){if(a.path!==e)throw new b.JsonPatchError('Cannot perform the operation at a path that does not exist','OPERATION_PATH_UNRESOLVABLE',c,a,d);}else if('move'===a.op||'copy'===a.op){var i={op:'_get',path:a.from,value:void 0},j=h([i],d);if(j&&'OPERATION_PATH_UNRESOLVABLE'===j.name)throw new b.JsonPatchError('Cannot perform the operation from a path that does not exist','OPERATION_FROM_UNRESOLVABLE',c,a,d)}}function h(a,c,d){try{if(!Array.isArray(a))throw new b.JsonPatchError('Patch sequence must be an array','SEQUENCE_NOT_AN_ARRAY');if(c)f(l._deepClone(c),l._deepClone(a),d||!0);else{d=d||g;for(var e=0;e<a.length;e++)d(a[e],e,c,void 0)}}catch(a){if(a instanceof b.JsonPatchError)return a;throw a}}var i={strict:!0},j=c(2),k=function(c,a){return j(c,a,i)},l=c(0);b.JsonPatchError=l.PatchError,b.deepClone=l._deepClone;var m={add:function(a,b,c){return a[b]=this.value,{newDocument:c}},remove:function(a,b,c){var d=a[b];return delete a[b],{newDocument:c,removed:d}},replace:function(a,b,c){var d=a[b];return a[b]=this.value,{newDocument:c,removed:d}},move:function(a,b,c){var f=d(c,this.path);f&&(f=l._deepClone(f));var g=e(c,{op:'remove',path:this.from}).removed;return e(c,{op:'add',path:this.path,value:g}),{newDocument:c,removed:f}},copy:function(a,b,c){var f=d(c,this.from);return e(c,{op:'add',path:this.path,value:l._deepClone(f)}),{newDocument:c}},test:function(a,b,c){return{newDocument:c,test:k(a[b],this.value)}},_get:function(a,b,c){return this.value=a[b],{newDocument:c}}},n={add:function(a,b,c){return l.isInteger(b)?a.splice(b,0,this.value):a[b]=this.value,{newDocument:c,index:b}},remove:function(a,b,c){var d=a.splice(b,1);return{newDocument:c,removed:d[0]}},replace:function(a,b,c){var d=a[b];return a[b]=this.value,{newDocument:c,removed:d}},move:m.move,copy:m.copy,test:m.test,_get:m._get};b.getValueByPointer=d,b.applyOperation=e,b.applyPatch=f,b.applyReducer=function(a,c){var d=e(a,c);if(!1===d.test)throw new b.JsonPatchError('Test operation failed','TEST_OPERATION_FAILED',0,c,a);return d.newDocument},b.validator=g,b.validate=h},function(a,b,c){function d(a){return null===a||a===void 0}function e(a){return a&&'object'==typeof a&&'number'==typeof a.length&&('function'!=typeof a.copy||'function'!=typeof a.slice?!1:0<a.length&&'number'!=typeof a[0]?!1:!0)}function f(c,f,l){var m,i;if(d(c)||d(f))return!1;if(c.prototype!==f.prototype)return!1;if(j(c))return!!j(f)&&(c=g.call(c),f=g.call(f),k(c,f,l));if(e(c)){if(!e(f))return!1;if(c.length!==f.length)return!1;for(m=0;m<c.length;m++)if(c[m]!==f[m])return!1;return!0}try{var n=h(c),o=h(f)}catch(a){return!1}if(n.length!=o.length)return!1;for(n.sort(),o.sort(),m=n.length-1;0<=m;m--)if(n[m]!=o[m])return!1;for(m=n.length-1;0<=m;m--)if(i=n[m],!k(c[i],f[i],l))return!1;return typeof c==typeof f}var g=Array.prototype.slice,h=c(5),j=c(4),k=a.exports=function(a,b,c){return c||(c={}),a===b||(a instanceof Date&&b instanceof Date?a.getTime()===b.getTime():a&&b&&('object'==typeof a||'object'==typeof b)?f(a,b,c):c.strict?a===b:a==b)}},function(a,b,c){function d(a){return o.get(a)}function e(a,b){return a.observers.get(b)}function f(a,b){a.observers.delete(b.callback)}function g(a){var b=o.get(a.object);h(b.value,a.object,a.patches,''),a.patches.length&&l.applyPatch(b.value,a.patches);var c=a.patches;return 0<c.length&&(a.patches=[],a.callback&&a.callback(c)),c}function h(a,b,c,d){if(b!==a){'function'==typeof b.toJSON&&(b=b.toJSON());for(var e=k._objectKeys(b),f=k._objectKeys(a),g=!1,i=!1,j=f.length-1;0<=j;j--){var l=f[j],m=a[l];if(k.hasOwnProperty(b,l)&&(void 0!==b[l]||void 0===m||!1!==Array.isArray(b))){var n=b[l];'object'==typeof m&&null!=m&&'object'==typeof n&&null!=n?h(m,n,c,d+'/'+k.escapePathComponent(l)):m!==n&&(g=!0,c.push({op:'replace',path:d+'/'+k.escapePathComponent(l),value:k._deepClone(n)}))}else c.push({op:'remove',path:d+'/'+k.escapePathComponent(l)}),i=!0}if(i||e.length!=f.length)for(var l,j=0;j<e.length;j++)l=e[j],k.hasOwnProperty(a,l)||void 0===b[l]||c.push({op:'add',path:d+'/'+k.escapePathComponent(l),value:k._deepClone(b[l])})}}var i={strict:!0},j=c(2),k=c(0),l=c(1),m=c(1);b.applyOperation=m.applyOperation,b.applyPatch=m.applyPatch,b.applyReducer=m.applyReducer,b.getValueByPointer=m.getValueByPointer,b.validate=m.validate,b.validator=m.validator;var n=c(0);b.JsonPatchError=n.PatchError,b.deepClone=n._deepClone,b.escapePathComponent=n.escapePathComponent,b.unescapePathComponent=n.unescapePathComponent;var o=new WeakMap,p=function(){return function(a){this.observers=new Map,this.obj=a}}(),q=function(){return function(a,b){this.callback=a,this.observer=b}}();b.unobserve=function(a,b){b.unobserve()},b.observe=function(a,b){var c,h=d(a);if(!h)h=new p(a),o.set(a,h);else{var i=e(h,b);c=i&&i.observer}if(c)return c;if(c={},h.value=k._deepClone(a),b){c.callback=b,c.next=null;var j=function(){g(c)},l=function(){clearTimeout(c.next),c.next=setTimeout(j)};'undefined'!=typeof window&&(window.addEventListener?(window.addEventListener('mouseup',l),window.addEventListener('keyup',l),window.addEventListener('mousedown',l),window.addEventListener('keydown',l),window.addEventListener('change',l)):(document.documentElement.attachEvent('onmouseup',l),document.documentElement.attachEvent('onkeyup',l),document.documentElement.attachEvent('onmousedown',l),document.documentElement.attachEvent('onkeydown',l),document.documentElement.attachEvent('onchange',l)))}return c.patches=[],c.object=a,c.unobserve=function(){g(c),clearTimeout(c.next),f(h,c),'undefined'!=typeof window&&(window.removeEventListener?(window.removeEventListener('mouseup',l),window.removeEventListener('keyup',l),window.removeEventListener('mousedown',l),window.removeEventListener('keydown',l)):(document.documentElement.detachEvent('onmouseup',l),document.documentElement.detachEvent('onkeyup',l),document.documentElement.detachEvent('onmousedown',l),document.documentElement.detachEvent('onkeydown',l)))},h.observers.set(b,new q(b,c)),c},b.generate=g,b.compare=function(a,b){var c=[];return h(a,b,c,''),c}},function(a,b){function c(a){return'[object Arguments]'==Object.prototype.toString.call(a)}function d(a){return a&&'object'==typeof a&&'number'==typeof a.length&&Object.prototype.hasOwnProperty.call(a,'callee')&&!Object.prototype.propertyIsEnumerable.call(a,'callee')||!1}var e='[object Arguments]'==function(){return Object.prototype.toString.call(arguments)}();b=a.exports=e?c:d,b.supported=c;b.unsupported=d},function(a,b){function c(a){var b=[];for(var c in a)b.push(c);return b}b=a.exports='function'==typeof Object.keys?Object.keys:c,b.shim=c}]);

var log_love = "%cDo you like %cSuper Forms? %cJoin the growing community of developers: %chttps://github.com/RensTillmann/super-forms";
setTimeout(console.log.bind(console, log_love, "color: #60B8FF", "", "color: #60B8FF", ""));
var sf_app = {};

// querySelector shorthand
sf_app.q = function(selector){
    return document.querySelector(selector);
}

// querySelectorAll shorthand
sf_app.qa = function(selector){
    return document.querySelectorAll(selector);
}

// Get index of element based on parent node
sf_app.index = function(node, class_name){
    var index = 0;
    while ( (node = node.previousElementSibling) ) {
        // Based on specified class name
        if(class_name) {
            if(node.classList.contains(class_name)){
                index++;
            }
        }else{
            index++;
        }
    }
    return index;
}

// Check if clicked inside element, by looping over it's "path"
sf_app.in_path = function(e, class_name){
    if(!e.path) return false;
    var found = false;
    Object.keys(e.path).forEach(function(key) {
        if(e.path[key].classList){
            if(e.path[key].classList.contains(class_name)){
                found = true;
            }
        }
    });
    return found;
};

// Get object property by string
sf_app.get_prop_by_string = function(obj, propString) {
    if (!propString)
        return obj;
    var prop;
    var props = propString.split('.');
    for(var i = 0, iLen = props.length - 1; i < iLen; i++) {
        prop = props[i];
        var candidate = obj[prop];
        if (candidate !== undefined) {
            obj = candidate;
        } else {
            break;
        }
    }
    return obj[props[i]];
}

/**
 * Get all DOM element up the tree that contain a class, ID, or data attribute
 * @param  {Node} elem The base element
 * @param  {String} selector The class, id, data attribute, or tag to look for
 * @return {Array} Null if no match
 */
sf_app.get_parents = function(elem, selector){
    var parents = [];
    var firstChar;
    if(selector){
        firstChar = selector.charAt(0);
    }
    // Get matches
    for(;elem && elem!==document; elem=elem.parentNode){
        if(selector){
            // If selector is a class
            if(firstChar==='.'){
                if(elem.classList.contains(selector.substr(1))){
                    parents.push(elem);
                }
            }
            // If selector is an ID
            if(firstChar==='#'){
                if(elem.id===selector.substr(1)){
                    parents.push(elem);
                }
            }
            // If selector is a data attribute
            if(firstChar==='['){
                if(elem.hasAttribute(selector.substr(1, selector.length - 1))){
                    parents.push(elem);
                }
            }
            // If selector is a tag
            if(elem.tagName.toLowerCase()===selector){
                parents.push( elem );
            }
        }else{
            parents.push( elem );
        }
    }
    // Return parents if any exist
    if(parents.length===0){
        return null;
    }else{ 
        return parents;
    }
};

sf_app.edit_panel = {
    close : function(){
        if(sf_app.q('.sf-edit-panel')) {
            sf_app.q('.sf-edit-panel').remove();
        }
    }
};

// Remove class from elements
sf_app.remove_class = function(elements, class_namee){
    for (var key = 0; key < elements.length; key++) {
        elements[key].classList.remove(class_namee);
    }
};

// Add class from elements
sf_app.add_class = function(elements, class_namee){
    for (var key = 0; key < elements.length; key++) {
        elements[key].classList.add(class_namee);
    }
};

// Get element by index array
sf_app.get_element_by_index_array = function(index_array){
    // Now we have all the elements with their indexes, we can highlight them
    var element = null;
    for (var key = 0; key < index_array.length; key++) {
        if(!element){
            element = sf_app.qa('.sf-drop-area.sf-active > .sf-element')[index_array[key].index];
        }else{
            // Search for inner element
            if(element.querySelector('.sf-inner')) {
                element = element.querySelector('.sf-inner').children[index_array[key].index];
            }
        }
    }
    return element;
};

// Define navigator
sf_app.navigator = {

    // Initialize sortable list
    init_sortable : function(){
        var containers = [].slice.apply(document.querySelectorAll('.sf-sortable'));
        var drake = dragula(containers, {
            isContainer: function (el) {
                return el.classList.contains('sf-sortable');
            },
            moves: function (el, source, handle, sibling) {
                return true; // elements are always draggable by default
            },
            accepts: function (el, target, source, sibling) {
                return true; // elements can be dropped in any of the `containers` by default
            },
            invalid: function (el, handle) {
                return false; // don't prevent any drags from initiating by default
            },
            direction: 'vertical', // Y axis is considered when determining where an element would be dropped
            copy: true, // elements are moved by default, not copied
            copySortSource: true, // elements in copy-source containers can be reordered
            revertOnSpill: false, // spilling will put the element back where it was dragged from, if this is true
            removeOnSpill: false, // spilling will `.remove` the element, if this is true
            mirrorContainer: document.querySelector('.sf-navigator .sf-list'), // set the element that gets mirror elements appended
            ignoreInputTextSelection: false // allows users to select input text, see details below
        });
        drake.on('drag',function(el, source){
            console.log('DRAG START');
            console.log(el, source);
            var indexes = sf_app.navigator.index_array_by_list(el),
                element = sf_app.get_element_by_index_array(indexes);
            element.classList.add('sf-highlighted');
        }).on('drop',function(el, target, source, sibling){
            console.log('DROPPED');
            console.log(el, target, source, sibling);
            console.log(sf_app.q('.sf-list'));

            // Check if we have a sibling, or if we are dropping it at the end of a column or at the end of the navigator list
            if(sibling && !sibling.classList.contains('gu-mirror')){ // This holds the item which the element should be dropped in front of
                console.log('we have a sibling');
                // We have a sibling
                var indexes = sf_app.navigator.index_array_by_list(sibling),
                    // Since the last index isn't correct, we must decrease it by 1
                    last_index = indexes[indexes.length-1].index - 1;
                //if(last_index<0) last_index = 0; // Of course index can never be below zero, cancel dropping...
                if(last_index<0) return true; // Of course index can never be below zero, cancel dropping...
                indexes[indexes.length-1].index = last_index;

                console.log(indexes);
                var target_element = sf_app.get_element_by_index_array(indexes),
                    parameters = {method: 'before'};
                console.log('Does it even exist????: ', target_element);
            }else{
                console.log('No sibling found, so we are either dropping this inside a column or at the very end');
                // No sibling found, so we are either dropping this inside a column or at the very end
                // If dropping at the very end
                if(target.classList.contains('sf-list')){
                    //Dropping at the very end of the form
                    console.log('Dropping at the very end of the form');
                    var children = sf_app.q('.sf-drop-area.sf-active').children,
                        target_element = children[children.length-1],
                        parameters = {method: 'after'};
                }else{
                    console.log('dropping at the end of a column');
                    /*
                    // If dropping at the end of a column
                    var sibling = target.parentNode,
                        indexes = sf_app.navigator.index_array_by_list(sibling),

                        // Since the last index isn't correct, we must increase it by 1
                        last_index = indexes[indexes.length-1].index + 1;

                    indexes[indexes.length-1].index = last_index;
                    var sibling_element = sf_app.get_element_by_index_array(indexes),
                        parameters = {method: 'inside'};

                    console.log(sibling);
                    console.log(indexes);
                    console.log(sibling_element);
                    */

                    // If dropping at the end of a column
                    var sibling = target.parentNode,
                        indexes = sf_app.navigator.index_array_by_list(sibling),
                        target_element = sf_app.get_element_by_index_array(indexes),
                        parameters = {method: 'inside'};
                    
                }
            }

            sf_app.move_element();
            console.log(target_element);
            sf_app.drop(undefined, target_element, undefined, parameters, false);

            // At the end make sure to delete the cloned element
            if(sf_app.q('.sf-list .sf-clone')) {
                sf_app.q('.sf-list .sf-clone').remove();
            }

        }).on('cloned', function(clone, original, type){
            console.log('CLONED');
            console.log(clone, original, type);
            original.classList.add('sf-clone');
        });
    },
    // Generate the list
    update : function(parts){
        if(typeof parts === 'undefined'){
            // Grab parts from form data
            var parts = sf_app.form_data().parts;
        }
        // Grab current drop area "part" index
        var part_index = sf_app.index(sf_app.q('.sf-drop-area.sf-active'), 'sf-drop-area');
        // Create elements, and add them to their corresponding part (drop area)
        var part = parts[part_index];
        var html = '';
        Object.keys(part.elements).forEach(function(key) {
            var data = part.elements[key];
            Object.keys(data).forEach(function(k) {
                var settings = data[k].settings,
                    inner = data[k].inner;
                html += sf_app.navigator.item_html(k);
                // Loop through inner elements
                html += sf_app.navigator.inner_elements(inner);
            });
            html += '</div>';
        });
        // Add elements to the navigator list
        sf_app.q('.sf-navigator .sf-list').innerHTML = html;
    },
    // Get indexes based on navigator list
    index_array_by_list : function(target){
        var indexes = [];
        var parents = sf_app.get_parents(target, '.sf-item');
        Object.keys(parents).forEach(function(key) {
            var index = sf_app.index(parents[key])
            indexes[key] = {
                index: index 
            };
        });
        indexes.reverse();
        return indexes;
    },
    // Get indexes based on navigator item
    index_array : function(target){
        var indexes = sf_app.navigator.index_array_by_list(target);
        var element = sf_app.get_element_by_index_array(indexes);
        if(element){
            var indexes = [];
            var parents = sf_app.get_parents(element.firstChild, '.sf-element');
            Object.keys(parents).forEach(function(key) {
                var index = sf_app.index(parents[key]),
                    name = parents[key].dataset['sfname'],
                    title = parents[key].dataset['sftitle'],
                    inner = true;
                if(!super_create_form_i18n.elements[name].inner){
                    inner = false;            
                }
                indexes[key] = {
                    index: index, 
                    name: name, 
                    title: title, 
                    inner: inner
                };
            });
        }
        return indexes.reverse();
    },
    item_html : function(k){
        var html = '<div class="sf-item sf-'+k+'" data-sfactions=\'{"mouseout":{"navigator.highlight":{}},"mouseover":{"navigator.highlight":{}},"click":{"navigator.edit":{}}}\'>';
        html += '<span class="sf-toggle" data-sfactions=\'{"mouseout":{"navigator.highlight":{}},"mouseover":{"navigator.highlight":{}},"click":{"navigator.toggle":{}}}\'></span>';
        html += '<span class="sf-visibility" data-sfactions=\'{"mouseout":{"navigator.highlight":{}},"mouseover":{"navigator.highlight":{}},"click":{"navigator.visibility":{}}}\'></span>';
        html += '<span class="sf-delete" data-sfactions=\'{"mouseout":{"navigator.highlight":{}},"mouseover":{"navigator.highlight":{}},"click":{"navigator.delete":{}}}\'></span>';
        html += '<span class="sf-title">'+super_create_form_i18n.elements[k].title+'</span>';
        return html
    },
    // Loop through inner elements
    inner_elements : function(inner){
        var html = '';
        if(inner){
            html += '<div class="sf-sortable">';
            Object.keys(inner).forEach(function(key) {
                var data = inner[key];
                Object.keys(data).forEach(function(k) {
                    html += sf_app.navigator.item_html(k);
                    html += sf_app.navigator.inner_elements(data[k].inner);
                });
                html += '</div>';
            });
            html += '</div>';
        }
        return html;
    },
    highlight : function(e, target, event, parameters){
        // Only execute hover effect if not dragging any items
        if(!sf_app.q('.sf-navigator .sf-list').classList.contains('gu-unselectable')){
            if(!target.classList.contains('sf-item')){
                target = target.parentNode;
            }
            if(!target.classList.contains('sf-hover')){
                var index = sf_app.index(target),
                    list = sf_app.navigator.index_array(target);
                // Now we have all the elements with their indexes, we can highlight them
                var element = null;
                for (var key = 0; key < list.length; key++) {
                    if(!element){
                        element = sf_app.qa('.sf-drop-area.sf-active > .sf-element')[list[key].index];
                    }else{
                        // Search for inner element
                        if(element.querySelector('.sf-inner')) {
                            element = element.querySelector('.sf-inner').children[list[key].index];
                        }
                    }
                }
                // Now highlight the element
                if(element){
                    // Remove highlight class from all highlighted elements
                    sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-highlighted'), 'sf-highlighted' );
                    sf_app.remove_class(sf_app.qa('.sf-list .sf-item.sf-hover'), 'sf-hover');
                    if(event=='mouseover'){
                        // Add highlight class to the element
                        element.classList.add('sf-highlighted');
                        target.classList.add('sf-hover');
                        // Scroll to element
                        element.scrollIntoView({behavior: "smooth", inline: "nearest"});

                    }
                }
            }
        }
    },
    edit : function(e, target, event, parameters){
        var index = sf_app.index(target),
            list = sf_app.navigator.index_array(target);
        // Now we have all the elements with their indexes, we can highlight them
        var element = null;
        for (var key = 0; key < list.length; key++) {
            if(!element){
                element = sf_app.qa('.sf-drop-area.sf-active > .sf-element')[list[key].index];
            }else{
                // Search for inner element
                if(element.querySelector('.sf-inner')) {
                    element = element.querySelector('.sf-inner').children[list[key].index];
                }
            }
        }
        sf_app.edit_element(e, element, event, parameters);
    },
    toggle : function(e, target){
        var parent = target.parentNode;
        if(parent.classList.contains('sf-open')){
            parent.classList.remove('sf-open');
        }else{
            parent.classList.add('sf-open');
        }
    },
    visibility : function(e, target, event, parameters){
        var list = sf_app.navigator.index_array(target);
        // Now we have all the elements with their indexes, we can highlight them
        var element = null;
        for (var key = 0; key < list.length; key++) {
            if(!element){
                element = sf_app.qa('.sf-drop-area.sf-active > .sf-element')[list[key].index];
            }else{
                // Search for inner element
                if(element.querySelector('.sf-inner')) {
                    element = element.querySelector('.sf-inner').children[list[key].index];
                }
            }
        }
        if(target.parentNode.classList.contains('sf-hidden')){
            target.parentNode.classList.remove('sf-hidden');
            // Now highlight the element
            if(element){
                element.classList.remove('sf-hidden');
            }
        }else{
            target.parentNode.classList.add('sf-hidden');
            if(element){
                element.classList.add('sf-hidden');
            }
        }
    },
    delete : function(e, target, event, parameters){
        var indexes = sf_app.navigator.index_array(target);
        sf_app.delete_based_on_index_array(indexes, false); // false = do not update navigator list
        target.parentNode.remove();
    },
    open : function(){
        sf_app.q('.sf-navigator').style.display = 'block';
    },
    close : function(){
        sf_app.q('.sf-navigator').style.display = 'none';
    },
    collapse_items : function(e, target){
        if(target.classList.contains('sf-open')){
            target.classList.remove('sf-open');
            sf_app.remove_class(sf_app.qa('.sf-list .sf-item.sf-open'), 'sf-open');
        }else{
            target.classList.add('sf-open');
            sf_app.add_class(sf_app.qa('.sf-list .sf-item'), 'sf-open');
        }
    },
    scrolling : function(e, target){
        console.log('scrolling navigator...');
    }
};

// Define context menu (right click menu)
sf_app.context_menu = {
    // Open the context menu
    open : function(target){
        // Close edit panel
        sf_app.edit_panel.close();
        // Remove highlight class from all highlighted elements
        // But only if right clicked on an element (exclude breadcrumb)
        // This check will also make sure to not add highligted class to breadcrumb
        if(target.classList.contains('sf-element')){
            sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-highlighted'), 'sf-highlighted' );
            // Highlight element
            target.classList.add('sf-highlighted');
        }
        // Remove editing class from any previously editing element
        sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-editing'), 'sf-editing' );
        // Create context menu
        var node  = document.createElement('div');
        node.className = 'sf-context-menu';
        node.style.position = 'absolute';
        var html  = '<ul>';
        html += '<li class="sf-edit" data-sfactions=\'{"click":{"edit_element":{}}}\'>Edit</li>';
        html += '<li class="sf-duplicate" data-sfactions=\'{"click":{"duplicate_element":{}}}\'>Duplicate</li>';
        html += '<li class="sf-move" data-sfactions=\'{"click":{"move_element":{}}}\'>Move</li>';
        html += '<li class="sf-copy" data-sfactions=\'{"click":{"copy_element":{}}}\'>Copy</li>';
        html += '<li class="sf-paste" data-sfactions=\'{"click":{"paste_element":{}}}\'>Paste</li>';
        html += '<li class="sf-delete" data-sfactions=\'{"click":{"delete_element":{}}}\'>Delete</li>';
        html += '</ul>';
        node.innerHTML = html;
        sf_app.q('body').appendChild(node);
        sf_app.context_menu.update_position();
    },
    close : function(){
        if(sf_app.q('.sf-breadcrumb-rmb')) {
            sf_app.q('.sf-breadcrumb-rmb').classList.remove('sf-breadcrumb-rmb');
        }  
        if(sf_app.q('.sf-context-menu')) {
            sf_app.q('.sf-context-menu').remove();
        }
    },
    // Get click position
    get_position : function(e) {
      var posx = 0;
      var posy = 0;
      if (!e) var e = window.event;
      if (e.pageX || e.pageY) {
        posx = e.pageX;
        posy = e.pageY;
      } else if (e.clientX || e.clientY) {
        posx = e.clientX + document.body.scrollLeft + 
                           document.documentElement.scrollLeft;
        posy = e.clientY + document.body.scrollTop + 
                           document.documentElement.scrollTop;
      }
      return {
        x: posx,
        y: posy
      }
    },
    // Update context menu position
    update_position : function(e) {
        var clickCoords = sf_app.context_menu.get_position(e);
        var clickCoordsX = clickCoords.x;
        var clickCoordsY = clickCoords.y;
        var menu = sf_app.q('.sf-context-menu');
        var menuWidth = menu.offsetWidth + 4;
        var menuHeight = menu.offsetHeight + 4;
        var windowWidth = window.innerWidth;
        var windowHeight = window.innerHeight;
        if ( (windowWidth - clickCoordsX) < menuWidth ) {
            menu.style.left = windowWidth - menuWidth + "px";
        } else {
            menu.style.left = clickCoordsX + "px";
        }
        if ( (windowHeight - clickCoordsY) < menuHeight ) {
            menu.style.top = windowHeight - menuHeight + "px";
        } else {
            menu.style.top = clickCoordsY + "px";
        }
    }
};

// Generate element HTML
sf_app.create_element = function(name, depth){
    if(typeof depth === 'undefined') depth = 0;
    // Generate the element HTML and append it to the canvas
    var node  = document.createElement('div');
    // Add class names, and make sure to remove any numbesr from the 'name' string
    var element_name = name.replace(/[0-9]/g, '');
    node.className = 'sf-element sf-'+element_name;
    // Add the element name as a data attribute
    node.dataset['sfname'] = element_name;
    // Add the element title as a data attribute
    node.dataset['sftitle'] = super_create_form_i18n.elements[name].title;
    // Add the action to edit the element
    node.dataset['sfactions'] = '{"mouseover":{"add_drop_buttons":{"name":"'+element_name+'"}},"click":{"edit_element":{"name":"'+element_name+'"}}}';
    // Check if we need to add a specific class
    if(super_create_form_i18n.elements[name].class){
        node.classList.add(super_create_form_i18n.elements[name].class);
    }
    var html = '<div class="sf-wrapper">';
    // Check if element can contain inner elements
    var inner = super_create_form_i18n.elements[name].inner;
    if(inner){
        html += '<div class="sf-inner"></div>';
    }
    // Check for custom HTML
    if(super_create_form_i18n.elements[name].html){
        html += super_create_form_i18n.elements[name].html;
    }
    html += '</div>';
    node.innerHTML = html;

    // Only if depth is 0
    if(inner && depth==0){
        Object.keys(inner).forEach(function(key) {
            // If we need to add this item more than 1 time
            if(!inner[key]) inner[key] = 1;
            var i = 0;
            while(inner[key] > i){
                node.querySelector('.sf-inner').appendChild(sf_app.create_element(key, 1));
                i++;
            }
        });
    }

    return node;
}

// Generate element HTML
sf_app.element_html = function(name, settings, inner){
    var extra_class = '',
        html = '',
        title = '';
    if(name=='column'){
        extra_class += ' sf-'+settings.size.replace('/','-');
        title = 'Column '+settings.size;
    }
    if(super_create_form_i18n.elements[name]){
        title = super_create_form_i18n.elements[name].title;
    }
    html += '<div class="sf-element sf-'+name+extra_class+'" data-sfname="'+name+'" data-sftitle="'+title+'" data-sfactions=\'{"mouseover":{"add_drop_buttons":{"name":"'+name+'"}},"click":{"edit_element":{"name":"'+name+'"}}}\'>';
        html += '<div class="sf-wrapper">';
            // If element does not have any inner elements
            if(!inner){
                html += sf_app.element_field_html(name, settings, inner);
            }else{
                // If element has inner elements generate the HTML
                var result = [];
                html += '<div class="sf-inner">';
                Object.keys(inner).forEach(function(key) {
                    var data = inner[key];
                    Object.keys(data).forEach(function(k) {
                        var name = k,
                              settings = data[k].settings,
                              inner = data[k].inner;
                        html += sf_app.element_html(name, settings, inner);
                    });
                });
                html += '</div>';
            }
        html += '</div>';
    html += '</div>';
    return html;
};

// Generate element field HTML
sf_app.element_field_html = function(name, settings, inner){
    var html = '',
        label = (settings.label && settings.label.value ? settings.label.value : super_create_form_i18n.elements[name].settings.label.value.default);
    if(label){
        html += '<div class="sf-label-desc">';
            if(label){
                html += '<div class="sf-label">'+label+'</div>';
            }
        html += '</div>';
    }
    html += '<div class="sf-field">';
        html += '<input type="text" placeholder="Dummy placeholder...">';
    html += '</div>';
    return html;
}

// Gather all indexes ordered from low to highest parent
// After we are done gathering all the correct indexes, we can reverse the array
// This way we will get the index from highest to lowest
sf_app.index_array = function(indexes, target){
    var parents = sf_app.get_parents(target, '.sf-element');
    Object.keys(parents).forEach(function(key) {
        var index = sf_app.index(parents[key]),
            name = parents[key].dataset['sfname'],
            title = parents[key].dataset['sftitle'],
            inner = true;
        if(!super_create_form_i18n.elements[name].inner){
            inner = false;            
        }
        indexes[key] = {
            index: index, 
            name: name, 
            title: title, 
            inner: inner
        };
    });
    return indexes.reverse();
}

// Breadcrumb mouseover or click event
sf_app.breadcrumb = {
    // Get indexes based on breadcrumb item
    index_array : function(target){
        var indexes = [],
            children = target.parentNode.children,
            index = sf_app.index(target),
            name = target.dataset['sfname'],
            title = target.dataset['sftitle'],
            inner = true;
        for (var key = 0; key < children.length; key++) {
            // Add child to the list
            indexes[key] = {
                index: children[key].dataset.index,
                name: name, 
                title: title
            };
            // Stop loop if reached target
            if(index==key) break;
        }
        return indexes;
    },
    highlight : function(e, target, event, parameters){
        // Do not close if right clicked on breadcrumb item
        if(e.toElement && e.toElement.classList.contains('sf-context-menu')){
            target.classList.add('sf-breadcrumb-rmb');
        }
        if(e.toElement && !e.toElement.classList.contains('sf-context-menu')){
            if(target.classList.contains('sf-breadcrumb-rmb')){
                return false;
            }
            // Close context menu
            sf_app.context_menu.close();
        }

        if(event=='mouseover' || event=='click'){
            // Find all children of the breadcrumb
            var children = target.parentNode.children,
                  list = [],
                  index = sf_app.index(target);
            for (var key = 0; key < children.length; key++) {
                // Add child to the list
                list.push(children[key].dataset.index);
                // Stop loop if reached target
                if(index==key) break;
            }
            // Now we have all the elements with their indexes, we can highlight them
            var element = null;
            for (var key = 0; key < list.length; key++) {
                if(!element){
                    element = sf_app.qa('.sf-drop-area.sf-active > .sf-element')[list[key]];
                }else{
                    // Search for inner element
                    if(element.querySelector('.sf-inner')) {
                        element = element.querySelector('.sf-inner').children[list[key]];
                    }
                }
            }

            // Remove highlight class from all highlighted elements
            sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-highlighted'), 'sf-highlighted' );

            if(event=='click'){
                // Highlight breadcrumb item
                if(target.closest('.sf-breadcrumb')){
                    sf_app.remove_class(target.parentNode.children, 'sf-highlighted');
                    target.classList.add('sf-highlighted');
                }
                // Breadcrumb click must not remove the breadcrumbs, so let's parse the parameter to avoid this
                var update_breadcrumbs = false;
                sf_app.edit_element(e, element, event, parameters, update_breadcrumbs);
            }else{
                // Now highlight the element
                if(element){
                    element.classList.add('sf-highlighted');
                }
            }
        }else{
            /*
            // Skip if inner element
            if(e.target === e.relatedTarget.parentNode) return;
            // Only remove highlighted element if not right clicked
            if(!e.toElement.classList.contains('sf-context-menu')){
                // Remove highlight class from all highlighted elements
                sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-highlighted'), 'sf-highlighted' );
            }
            */
        }
    },
    delete : function(){
        if(sf_app.q('.sf-breadcrumb')){
            sf_app.q('.sf-breadcrumb').remove();
        }
    }
}

// Tooltipper
sf_app.tooltip = {
    close : function(){
        // First remove any other tooltip
        if(sf_app.q('.sf-tooltipper')){
            sf_app.q('.sf-tooltipper').remove();
        }
    },
    show : function(e, target, event, parameters){
        // First remove any other tooltip
        sf_app.tooltip.close();
        // Create tooltip 
        var node  = document.createElement('div');
        node.classList.add('sf-tooltipper');

        node.innerHTML = target.dataset.sftooltip;
        // Get the position relative to the viewport (i.e. the window)
        var offset = target.getBoundingClientRect();
        var target_absolute_position_left = offset.left+(offset.width/2);
        //var margins = getComputedStyle(target);
        //var target_height = target.offsetHeight + parseInt(margins.marginTop) + parseInt(margins.marginBottom);
        var w = window,
            d = document,
            e = d.documentElement,
            g = d.getElementsByTagName('body')[0],
            window_width = w.innerWidth || e.clientWidth || g.clientWidth,
            window_height = w.innerHeight|| e.clientHeight|| g.clientHeight,
            scrollTop = window.pageYOffset || (document.documentElement || document.body.parentNode || document.body).scrollTop;
        node.style.position = 'absolute';
        node.style.top = 0;
        node.style.left = 0;
        // Append the node
        sf_app.q('body').appendChild(node);
        var initial_width = node.offsetWidth;
        if(typeof parameters.position === 'undefined'){
            node.style.top = offset.top+scrollTop+'px';
            node.style.transform = 'translateX(-50%) translateY(-150%)';
        }
        if(typeof parameters.position !== 'undefined'){
            node.classList.add('sf-bottom');
            node.style.top = offset.top+scrollTop+(offset.height)+'px';
            node.style.transform = 'translateX(-50%) translateY(50%)';
        }
        node.style.left = target_absolute_position_left+'px';
        // Check if we can't position the element at top or bottom because of overlapping window
        // The tooltip could possibly be cut off if we do not check this
        if(window_width < target_absolute_position_left+initial_width){
            // We have to position the tooltip to the left side of the target
            node.style.transform = null;
            node.style.left = (offset.left-initial_width-30)+'px';
            node.classList.remove('sf-bottom');
            node.classList.add('sf-left');
        }
        return false;
    }
};

// Delete based on index array
sf_app.delete_based_on_index_array = function(indexes, update_navigator){
    if(typeof update_navigator === 'undefined') var update_navigator = true;

    // Get element based of indexes
    var element = null;
    for (var key = 0; key < indexes.length; key++) {
        if(!element){
            element = sf_app.qa('.sf-drop-area.sf-active > .sf-element')[indexes[key].index];
        }else{
            // Search for inner element
            if(element.querySelector('.sf-inner')) {
                element = element.querySelector('.sf-inner').children[indexes[key].index];
            }
        }
    }
    // Grab current form data
    var data = sf_app.form_data();
    // Grab current drop area "part" index
    var part_index = sf_app.index(sf_app.q('.sf-drop-area.sf-active'), 'sf-drop-area');
    // Generate search string
    var search_string = '';
    Object.keys(indexes).forEach(function(key) {
        if(indexes.length==(parseFloat(key)+1)){
            search_string += '/'+indexes[key].index;
        }else{
            if(indexes[key].inner){
                search_string += '/'+indexes[key].index+'/'+(indexes[key].name.replace(/[0-9]/g, ''))+'/inner';
            }else{
                search_string += '/'+indexes[key].index+'/'+(indexes[key].name.replace(/[0-9]/g, ''));
            }
        }
    });
    search_string = '/parts/'+part_index+'/elements'+search_string;
    // Remove from json
    var query = { op: "remove", path: search_string };
    data = jsonpatch.applyOperation(data, query).newDocument;
    // Update local storage
    sf_app.save_form_data(data, update_navigator);
    // Remove edit panel
    sf_app.edit_panel.close();
    // Close context menu
    sf_app.context_menu.close();
    // Remove the element
    if(element){
        element.remove();
    }
    return data;
}

// Get highlighted element
sf_app.get_highlighted_element = function(){
    return sf_app.q('.sf-drop-area.sf-active .sf-highlighted');
}

// Move element
sf_app.move_element = function(){
    // First close any other tooltip
    sf_app.tooltip.close();
    // Activate moving status
    sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-moving'), 'sf-moving' );
    sf_app.get_highlighted_element().classList.add('sf-moving');
    // Remove dropping state
    sf_app.q('.sf-form').classList.remove('sf-dropping');
    // Remove active class on item in elements list
    sf_app.remove_class(sf_app.qa('.sf-item.sf-active'), 'sf-active' );
    // Add moving state
    sf_app.q('.sf-form').classList.add('sf-moving');
    // Close context menu
    sf_app.context_menu.close();
}

// Duplicate element
sf_app.duplicate_element = function(e, target){
    var source = sf_app.get_highlighted_element(),
        source_indexes = sf_app.index_array([], source),
        source_query = '',
        target_query = '',
        target_index = source_indexes[0].index,
        node = source.cloneNode(true);
    // Grab current form data
    var data = sf_app.form_data();
    // Grab current drop area "part" index
    var part_index = sf_app.index(sf_app.q('.sf-drop-area.sf-active'), 'sf-drop-area');
    // Get query for moving element
    Object.keys(source_indexes).forEach(function(key) {
        if(source_indexes.length==(parseFloat(key)+1)){
            source_query += '/'+source_indexes[key].index;
            //target_query += '/'+source_indexes[key].index;
        }else{
            if(source_indexes[key].inner){
                source_query += '/'+source_indexes[key].index+'/'+(source_indexes[key].name.replace(/[0-9]/g, ''))+'/inner';
                target_query += '/'+source_indexes[key].index+'/'+(source_indexes[key].name.replace(/[0-9]/g, ''))+'/inner';
            }else{
                source_query += '/'+source_indexes[key].index;
                target_query += '/'+source_indexes[key].index;
            }
        }
        target_index = source_indexes[key].index;
    });
    source_query = '/parts/'+part_index+'/elements'+source_query;
    target_query = '/parts/'+part_index+'/elements'+target_query;
    var source_data = jsonpatch.getValueByPointer(data, source_query);
    var target_data = jsonpatch.getValueByPointer(data, target_query);
    target_data.splice(target_index+1, 0, source_data);
    // Duplicate the node itself
    source.parentNode.insertBefore(node, source);
    // Update local storage
    sf_app.save_form_data(data);
    // Close context menu
    sf_app.context_menu.close();
    // Remove drop buttons
    sf_app.remove_drop_buttons();
    // Remove dropping or moving state
    sf_app.remove_class(sf_app.qa('.sf-dropping'), 'sf-dropping' );
    sf_app.remove_class(sf_app.qa('.sf-moving'), 'sf-moving' );
    // Close any tooltip
    sf_app.tooltip.close();
    // Remove highlight class from all highlighted elements
    sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-highlighted'), 'sf-highlighted' );
    // Remove editing class from any previously editing element
    sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-editing'), 'sf-editing' );
};

// Delete element
sf_app.delete_element = function(e, target, event, parameters){
    // Remove drop buttons
    sf_app.remove_drop_buttons();
    // Remove dropping or moving state
    sf_app.remove_class(sf_app.qa('.sf-dropping'), 'sf-dropping' );
    sf_app.remove_class(sf_app.qa('.sf-moving'), 'sf-moving' );
    // Close any tooltip
    sf_app.tooltip.close();
    // Get target by highlighted class
    target = sf_app.get_highlighted_element();
    parameters.name = target.dataset.sfname;
    // Remove highlight class from all highlighted elements
    sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-highlighted'), 'sf-highlighted' );
    // Remove editing class from any previously editing element
    sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-editing'), 'sf-editing' );
    // Delete element from json
    var indexes = sf_app.index_array([], target);
    sf_app.delete_based_on_index_array(indexes);
    // Remove breadcrumb
    sf_app.breadcrumb.delete();
}

// Edit element
sf_app.edit_element = function(e, target, event, parameters, update_breadcrumbs){
    if(typeof update_breadcrumbs === 'undefined') update_breadcrumbs = true;
    // Remove drop buttons
    sf_app.remove_drop_buttons();
    // Remove dropping or moving state
    sf_app.remove_class(sf_app.qa('.sf-dropping'), 'sf-dropping' );
    sf_app.remove_class(sf_app.qa('.sf-moving'), 'sf-moving' );
    // Close any tooltip
    sf_app.tooltip.close();
    // When editing through context menu, grab target by highlighted class
    if(!target.classList.contains('sf-element')){
        target = sf_app.get_highlighted_element();
        parameters.name = target.dataset.sfname.replace(/[0-9]/g, '');
    }
    // Remove highlight class from all highlighted elements
    sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-highlighted'), 'sf-highlighted' );
    // Remove editing class from any previously editing element
    sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-editing'), 'sf-editing' );
    // Now highlight the element
    if(target){
        target.classList.add('sf-editing');
    }
    // Gather indexes based on parents
    var index_array = sf_app.index_array([], target);
    // Generate breadcrumb HTML
    var html = '<ul>';
        var total = index_array.length-1;
        Object.keys(index_array).forEach(function(key) {
            var title = index_array[key].title.replace(/[0-9/]/g, '');
            html += '<li'+(key>=total ? ' class="sf-highlighted"' : '')+' data-sfname="'+index_array[key].name+'" data-sftitle="'+title+'" data-sftooltip="Edit element" data-sfactions=\'{"mouseout":{"breadcrumb.highlight":{}},"mouseover":{"tooltip.show":{"position":"bottom"},"breadcrumb.highlight":{"name":"'+index_array[key].name+'"}},"click":{"breadcrumb.highlight":{"name":"'+index_array[key].name+'"}}}\' data-index="'+index_array[key].index+'">';
            html += title;
            html += '<span data-sftooltip="Delete element" data-sfactions=\'{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"delete_element":{}}}\'></span>';
            html += '</li>';
            //search_string += '/'+index_array[key].index+'/'+(index_array[key].name.replace(/[0-9]/g, ''))+'/inner';
        });
    html += '</ul>';
    // Only update or create breadcrumb if editing was not initiated based of a breadcrumb item
    if(update_breadcrumbs){
        var breadcrumb = sf_app.q('.sf-breadcrumb');
        if(breadcrumb){
            // Update breadcrumb
            breadcrumb.innerHTML = html
        }else{
            // Create breadcrumb, and insert before first child of builder
            var node  = document.createElement('div');
            node.className = 'sf-breadcrumb';
            node.innerHTML = html;
            var parent = sf_app.q('.sf-builder');
            parent.insertBefore(node, parent.childNodes[0]);
        }
    }
    // Get the position relative to the viewport (i.e. the window)
    var window_width = window.innerWidth || document.documentElement.clientWidth || document.getElementsByTagName('body')[0].clientWidth,
        window_height = window.innerHeight|| document.documentElement.clientHeight|| document.getElementsByTagName('body')[0].clientHeight,
        scrollTop = window.pageYOffset || (document.documentElement || document.body.parentNode || document.body).scrollTop,
        target_offset = target.getBoundingClientRect(),
        canvas = sf_app.q('.sf-canvas'),
        canvas_offset = canvas.getBoundingClientRect(),
        form = sf_app.q('.sf-canvas .sf-form'),
        form_offset = form.getBoundingClientRect(),
        edit_panel = sf_app.q('.sf-edit-panel');
    if(edit_panel){
        // Update breadcrumb
        edit_panel.innerHTML = 'Element settings...'+parameters.name;
        // Re-position the panel
        edit_panel.style.transform = 'translateX(-50%)';
        edit_panel.style.top = (target_offset.top+target_offset.height+50)+scrollTop+'px';
        edit_panel.style.left =  (form_offset.left+(form_offset.width/2))+'px';
        edit_panel.style.width = canvas_offset.width+'px';
    }else{
        // Generate Edit Panel
        var node  = document.createElement('div');
        node.classList.add('sf-edit-panel');
        node.style.position = 'absolute';
        node.style.top = 0;
        node.style.left = 0;
        // Set panel width based on canvas width
        node.innerHTML = 'Element settings...'+parameters.name;
        node.style.transform = 'translateX(-50%)';
        // Append the node
        sf_app.q('body').appendChild(node);
        // Position the panel
        node.style.transform = 'translateX(-50%)';
        node.style.top = (target_offset.top+target_offset.height+50)+scrollTop+'px';
        node.style.left =  (form_offset.left+(form_offset.width/2))+'px';
        node.style.width = canvas_offset.width+'px';
    }
    // Close context menu
    sf_app.context_menu.close();
}

// Drop element inside (for instance inside a column)
sf_app.drop = function(e, target, event, parameters, update_navigator){
    if(typeof update_navigator === 'undefined') var update_navigator = true;
    // Get dropping method e.g before, inside, after
    var method = parameters.method;
    // Close edit panel
    sf_app.edit_panel.close();
    // Close any tooltip
    sf_app.tooltip.close();
    // Grab current form data
    var data = sf_app.form_data();
    // Grab current drop area "part" index
    var part_index = sf_app.index(sf_app.q('.sf-drop-area.sf-active'), 'sf-drop-area');

    // Are we adding, or moving an element?
    // We are moving an element
    if(sf_app.q('.sf-form').classList.contains('sf-moving')){
        var source = sf_app.get_highlighted_element(),
            target_element = (target.classList.contains('sf-element') ? target : target.closest('.sf-element')),
            source_indexes = sf_app.index_array([], source),
            target_indexes = sf_app.index_array([], target_element),
            source_query = '',
            source_query_delete = '',
            target_query = '',
            target_index = target_indexes[0].index,
            increase_index = false;

        // Possibly that the elements are in the same parent container
        // In that case we must alter the index when we DELETE the data from the json
        if(source_indexes.length == target_indexes.length){
            if(source.parentNode == target_element.parentNode){
                // We confirmed that both elements share the same parent container
                increase_index = true;
            }
        }

        console.log('### find out if we are moving a child element in front of its current parent, so that they share the same parent afterwards ###');
        var same_parent = false;
        if(source_indexes[0].index == target_indexes[0].index){
            same_parent = true;
        }
        console.log('#same parent: ', same_parent);
        console.log(source_indexes.length);
        console.log(source_indexes);
        console.log(target_indexes.length);
        console.log(target_indexes);
        console.log(source);
        console.log(source.parentNode);
        console.log(target_element);
        console.log(target_element.parentNode);
        console.log('### end ###');

        // Get query for moving element
        Object.keys(source_indexes).forEach(function(key) {
            if(source_indexes.length==(parseFloat(key)+1)){
                source_query += '/'+source_indexes[key].index;
                if(method=='after'){
                    source_query_delete += '/'+(parseFloat(source_indexes[key].index));
                }else{
                    source_query_delete += '/'+(parseFloat(source_indexes[key].index)+1);
                }
            }else{
                if(source_indexes[key].inner){
                    source_query += '/'+source_indexes[key].index+'/'+(source_indexes[key].name.replace(/[0-9]/g, ''))+'/inner';
                    source_query_delete += '/'+source_indexes[key].index+'/'+(source_indexes[key].name.replace(/[0-9]/g, ''))+'/inner';
                }else{
                    source_query += '/'+source_indexes[key].index;
                    source_query_delete += '/'+source_indexes[key].index;
                }
            }
        });
        source_query = '/parts/'+part_index+'/elements'+source_query;
        source_query_delete = '/parts/'+part_index+'/elements'+source_query_delete;
        console.log('###source query is: ', source_query);
        console.log('###data is: ', data);
        var source_data = jsonpatch.getValueByPointer(data, source_query);
        console.log('###source_data is: ', source_data);

        if(!increase_index) {
            console.log('increase_index: ', increase_index);
            if(method==='before' || method=='after'){
                console.log('test1');
                // We do not want to delete data from the json just yet...
            }else{
                console.log('test2');
                jsonpatch.applyOperation(data, { op: "remove", path: source_query }).newDocument;
            }
        }

        if(method==='before' || method=='after'){
            console.log('test3');
            // Get query to retrieve target data
            if(target_indexes.length>1){
                Object.keys(target_indexes).forEach(function(key) {
                    if(target_indexes.length!=(parseFloat(key)+1)){
                        if(target_indexes[key].inner){
                            target_query += '/'+target_indexes[key].index+'/'+(target_indexes[key].name.replace(/[0-9]/g, ''))+'/inner';
                        }
                    }
                    target_index = target_indexes[key].index;
                });
            }
            console.log('test4');
            target_query = '/parts/'+part_index+'/elements'+target_query;
            var target_data = jsonpatch.getValueByPointer(data, target_query);
            console.log(target_data);
            // Delete old element from json
            if(increase_index) {
                console.log('test5');
                source_query = source_query_delete;
                console.log(source_query_delete);
            }
            if(method==='before'){
                console.log('test6');
                // Drop element before target element
                // Add element to different location in json
                target_data.splice(target_index, 0, source_data);
                // Drop element before target element
                // First clone the node, then add it, so that we keep the original source, which we will delete later on.
                // This way we can retrieve the original source index array, because we require this later on.
                var node = source.cloneNode(true);
                target_element.parentNode.insertBefore(node, target_element);
            }
            if(method==='after'){
                console.log('test7');
                // Drop element after target element
                // Add element to different location in json
                target_data.splice(target_index+1, 0, source_data);
                // Drop element after target element
                // First clone the node, then add it, so that we keep the original source, which we will delete later on.
                // This way we can retrieve the original source index array, because we require this later on.
                var node = source.cloneNode(true);
                target_element.parentNode.insertBefore(node, target_element.nextSibling);
            }

            // Ok now we are ready to delete the data from the json data
            // This will remove the source element (which we already moved to it's other position)
            if(!increase_index) {
                console.log('test8');
                console.log('source_query 1: ',source_query);

                // @important, we need to grab the source indexes again, and regenerate the source_query, because the indexes will not match anymore, 
                // since we already moved the target on the canvas.
            var source_indexes = sf_app.index_array([], source),
                source_query = '';

                // Get query for moving element
                Object.keys(source_indexes).forEach(function(key) {
                    if(source_indexes.length==(parseFloat(key)+1)){
                        source_query += '/'+source_indexes[key].index;
                    }else{
                        if(source_indexes[key].inner){
                            source_query += '/'+source_indexes[key].index+'/'+(source_indexes[key].name.replace(/[0-9]/g, ''))+'/inner';
                        }else{
                            source_query += '/'+source_indexes[key].index;
                        }
                    }
                });
                source_query = '/parts/'+part_index+'/elements'+source_query;
                console.log('source_query 3: ',source_query);
                jsonpatch.applyOperation(data, { op: "remove", path: source_query }).newDocument;
                console.log('test9');
                // Now we can savely remove the original (source) element from the canvas
                source.remove();
            }

        }
        if(method==='inside'){
            // Drop element inside (as last child)
            // Get query for drop after element
            // Add the element to the form data
            Object.keys(target_indexes).forEach(function(key) {
                target_query += '/'+target_indexes[key].index+'/'+(target_indexes[key].name.replace(/[0-9]/g, ''))+'/inner';
            });
            target_query = '/parts/'+part_index+'/elements'+target_query;
            var target_data = jsonpatch.getValueByPointer(data, target_query);
            if(!target_data){
                // Inner data doesn't exist, create it
                var query = { op : "add", path : search_string, value : [] };
                data = jsonpatch.applyOperation(data, query).newDocument;
                target_data = jsonpatch.getValueByPointer(data, search_string);
            }
            // Push element to inner data
            target_data.push(source_data);
            // Drop element inside target element
            var node = source.cloneNode(true);
            target_element.querySelector('.sf-inner').appendChild(node);
        }
        // Delete old element from json
        if(increase_index) {

                // @important, we need to grab the source indexes again, and regenerate the source_query, because the indexes will not match anymore, 
                // since we already moved the target on the canvas.
            var source_indexes = sf_app.index_array([], source),
                source_query = '';

                // Get query for moving element
                Object.keys(source_indexes).forEach(function(key) {
                    if(source_indexes.length==(parseFloat(key)+1)){
                        source_query += '/'+source_indexes[key].index;
                    }else{
                        if(source_indexes[key].inner){
                            source_query += '/'+source_indexes[key].index+'/'+(source_indexes[key].name.replace(/[0-9]/g, ''))+'/inner';
                        }else{
                            source_query += '/'+source_indexes[key].index;
                        }
                    }
                });
                source_query = '/parts/'+part_index+'/elements'+source_query;
                console.log('source_query 32: ',source_query);
                jsonpatch.applyOperation(data, { op: "remove", path: source_query }).newDocument;
                console.log('test92');
                // Now we can savely remove the original (source) element from the canvas
                source.remove();
        }
    }
    // We are dropping an element
    if(sf_app.q('.sf-form').classList.contains('sf-dropping')){
        // Get name of the element we want to drop
        var name = sf_app.q('.sf-item.sf-active').dataset.name;
        // Remove highlight class from all highlighted elements
        sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-highlighted'), 'sf-highlighted' );
        // Remove editing class from any previously editing element
        sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-editing'), 'sf-editing' );
        // Grab the element default values
        var new_element = {};
        new_element[name.replace(/[0-9]/g, '')] = sf_app.get_element_defaults(name);
        // If we need to add this item more than 1 time
        // For instance with columns we require to add 3 columns if we selected to add the 1/3 grid
        if(!super_create_form_i18n.elements[name].times) super_create_form_i18n.elements[name].times = 1;
        var i = 0;
        while(super_create_form_i18n.elements[name].times > i){
            if(method==='before' || method=='after'){
                // Gather indexes based on parents
                var parent_element = target.closest('.sf-element');
                var index_array = sf_app.index_array([], parent_element);
                // Add the element to the form data
                var search_string = '';
                var element_index = index_array[0].index;
                if(index_array.length>1){
                    Object.keys(index_array).forEach(function(key) {
                        if(index_array.length==(parseFloat(key)+1)){
                            //search_string += '/'+index_array[key].index;
                        }else{
                            if(index_array[key].inner){
                                search_string += '/'+index_array[key].index+'/'+(index_array[key].name.replace(/[0-9]/g, ''))+'/inner';
                            }else{
                                search_string += '/'+index_array[key].index;
                            }
                        }
                        element_index = index_array[key].index;
                    });
                }
                // /parts/0/elements/0/column/inner/1/column/inner
                search_string = '/parts/'+part_index+'/elements'+search_string;
                // Get current inner data
                var inner_data = jsonpatch.getValueByPointer(data, search_string);
                if(method==='before'){
                    // Add element to inner data at correct index position, without deleting other items
                    inner_data.splice(element_index, 0, new_element);
                    // Drop element before target element
                    parent_element.parentNode.insertBefore(sf_app.create_element(name), parent_element);
                }
                if(method==='after'){
                    // Add element to inner data at correct index position, without deleting other items
                    inner_data.splice(element_index+1, 0, new_element);
                    // Drop element before target element
                    parent_element.parentNode.insertBefore(sf_app.create_element(name), parent_element.nextSibling);
                }
            }
            if(method==='inside'){
                // Drop element inside (as last child)
                target.parentNode.querySelector('.sf-inner').appendChild(sf_app.create_element(name));
                // Gather indexes based on parents
                var index_array = sf_app.index_array([], target);
                // Add the element to the form data
                var search_string = '';
                Object.keys(index_array).forEach(function(key) {
                    search_string += '/'+index_array[key].index+'/'+(index_array[key].name.replace(/[0-9]/g, ''))+'/inner';
                });
                search_string = '/parts/'+part_index+'/elements'+search_string;
                // Get current inner data
                var inner_data = jsonpatch.getValueByPointer(data, search_string);
                if(!inner_data){
                    // Inner data doesn't exist, create it
                    var query = { op : "add", path : search_string, value : [] };
                    data = jsonpatch.applyOperation(data, query).newDocument;
                    inner_data = jsonpatch.getValueByPointer(data, search_string);
                }
                // Push element to inner data
                inner_data.push(new_element);
                //// Push inner data to the form data
                //var query = { op: "replace", path: search_string, value: inner_data };
                //data = jsonpatch.applyOperation(data, query).newDocument;
            }
            i++; // Continue this loop
        }

    }
    // Update local storage
    sf_app.save_form_data(data, update_navigator);
    // After the element was added, remove dropping or moving class
    sf_app.q('.sf-form').classList.remove('sf-dropping');
    sf_app.q('.sf-form').classList.remove('sf-moving');
    // Remove highlight and moving class from element
    sf_app.remove_class(sf_app.qa('.sf-highlighted'), 'sf-highlighted' );
    sf_app.remove_class(sf_app.qa('.sf-moving'), 'sf-moving' );
    // Also remove all the drop buttons
    var nodes = sf_app.qa('.sf-drop-btn');
    Object.keys(nodes).forEach(function(key) {
        nodes[key].remove();
    });
    // Remove breadcrumb
    sf_app.breadcrumb.delete();
    // Also remove all drop here classes
    sf_app.remove_class(sf_app.qa('.sf-inner.sf-drop-here'), 'sf-drop-here' );
    // Remove active class on item in elements list
    sf_app.remove_class(sf_app.qa('.sf-item.sf-active'), 'sf-active' );
}

// Get default setting from an element
sf_app.get_element_defaults = function(name){
    var obj = {},
          defaults = {},
          inner_elements = [],
          settings = super_create_form_i18n.elements[name].settings,
          inner = super_create_form_i18n.elements[name].inner;
    Object.keys(settings).forEach(function(key) {
        if(settings[key].default){
            defaults[key] = settings[key].default;
        }
    });
    obj.settings = defaults;
    if(inner){
        Object.keys(inner).forEach(function(key) {
            var new_element = {};
            new_element[key] = sf_app.get_element_defaults(key);
            inner_elements.push(new_element);
        });
        obj.inner = inner_elements;
    }
    return obj;
}

// Add element to drop area
sf_app.add_element = function(e, target, event, parameters){
    
    // Close edit panel
    sf_app.edit_panel.close();
    // Remove highlight class from all highlighted elements
    sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-highlighted'), 'sf-highlighted' );
    // Remove editing class from any previously editing element
    sf_app.remove_class(sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-editing'), 'sf-editing' );    
    // Get element name
    var name = parameters.name;
    // Grab current drop area "part" index
    var part_index = sf_app.index(sf_app.q('.sf-drop-area.sf-active'), 'sf-drop-area');
    // Check if the active drop area has no elements yet, then instantly add it to the canvas
    if(sf_app.q('.sf-drop-area.sf-active').children.length==0){
        // Grab the element default values
        var new_element = {};
        new_element[name.replace(/[0-9]/g, '')] = sf_app.get_element_defaults(name);
        // If we need to add this item more than 1 time
        // For instance with columns we require to add 3 columns if we selected to add the 1/3 grid
        if(!super_create_form_i18n.elements[name].times) super_create_form_i18n.elements[name].times = 1;
        var i = 0;
        var data = sf_app.form_data();
        while(super_create_form_i18n.elements[name].times > i){
            // Append the element
            sf_app.q('.sf-drop-area.sf-active').appendChild(sf_app.create_element(name));
            // Add the element to the form data
            data.parts[part_index].elements.push(new_element);
            i++;
        }
        // Remove dropping status
        sf_app.q('.sf-form').classList.remove('sf-dropping');
        // Update local storage
        sf_app.save_form_data(data);
    }else{
        // Add global dropping class
        // There is at least one element, so let's activate dropping status
        sf_app.q('.sf-form').classList.add('sf-dropping');
        // Remove any active class from current items
        sf_app.remove_class(sf_app.qa('.sf-item.sf-active'), 'sf-active' );
        // First give clicked element active state
        sf_app.q('.sf-item.sf-type-'+name).classList.add('sf-active');
        // At this stage, we are listening for user hovering over any element.
        // When they hover over an element the "Drop here" buttons will be generated for that element (including any parent columns if any)
    }
}

// Remove drop buttons
sf_app.remove_drop_buttons = function(){
    var nodes = sf_app.qa('.sf-drop-btn');
    Object.keys(nodes).forEach(function(key) {
        nodes[key].remove();
    });
    // Also remove all drop here classes
    sf_app.remove_class(sf_app.qa('.sf-inner.sf-drop-here'), 'sf-drop-here' );
};

// Add drop here buttons
sf_app.add_drop_buttons = function(e, target, event, parameters){
   
    // First remove all hover classes
    sf_app.remove_class(sf_app.qa('.sf-element.sf-hover'), 'sf-hover' );   
    
    // Retrieve all possible parent elements such as columns and multi-parts
    var nodes = sf_app.get_parents(target, '.sf-element');
    if(nodes){
        Object.keys(nodes).forEach(function(key) {
            var element = nodes[key],
                wrapper = element.querySelector('.sf-wrapper'),
                inner = wrapper.querySelector('.sf-inner'),
                name = element.dataset.sfname
            element.classList.add('sf-hover');
            if(!nodes[key].querySelector('.sf-wrapper > .sf-inner')){
                // Only add drop buttons if they don't exist yet
                if(!nodes[key].querySelector('.sf-drop-btn')){
                    var name = nodes[key].dataset.sfname;
                    // Add drop here class
                    nodes[key].classList.add('sf-drop-here');
                    // Add "Drop before" button
                    var node  = document.createElement('div');
                    node.className = 'sf-drop-btn sf-drop-before';
                    node.dataset['sftooltip'] = 'Drop before '+super_create_form_i18n.elements[name].title+' field';
                    node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"before"}}}';
                    nodes[key].appendChild(node);
                    // Add "Drop after" button
                    var node  = document.createElement('div');
                    node.className = 'sf-drop-btn sf-drop-after';
                    node.dataset['sftooltip'] = 'Drop after '+super_create_form_i18n.elements[name].title+' field';
                    node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"after"}}}';
                    nodes[key].appendChild(node);
                }
            }else{
                // Only add drop buttons if they don't exist yet
                if(!wrapper.querySelectorAll(':scope > .sf-drop-btn').length){
                    // Add drop here class
                    inner.classList.add('sf-drop-here');
                    // Add "Drop before" button
                    var node  = document.createElement('div');
                    node.className = 'sf-drop-btn sf-drop-before';
                    node.dataset['sftooltip'] = 'Drop before '+super_create_form_i18n.elements[name].title;
                    node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"before"}}}';
                    wrapper.appendChild(node);
                    // Add "Drop inside" button
                    var node  = document.createElement('div');
                    node.className = 'sf-drop-btn sf-drop-inside';
                    node.dataset['sftooltip'] = 'Drop inside '+super_create_form_i18n.elements[name].title;
                    node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"inside"}}}';
                    wrapper.appendChild(node);
                    // Add "Drop after" button
                    var node  = document.createElement('div');
                    node.className = 'sf-drop-btn sf-drop-after';
                    node.dataset['sftooltip'] = 'Drop after '+super_create_form_i18n.elements[name].title;
                    node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"after"}}}';
                    wrapper.appendChild(node);
                }
            }
        });
    }
    
    /*
    if( 
        (e.fromElement.classList.contains('sf-inner') && e.toElement.classList.contains('sf-inner')) ||
        (e.fromElement.classList.contains('sf-inner') && e.toElement.className=='sf-wrapper') ||
        (e.fromElement.className=='sf-wrapper' && e.toElement.classList.contains('sf-inner')) ||
        (e.fromElement.classList.contains('sf-drop-btn') && e.toElement.classList.contains('sf-inner')) ||
        (e.fromElement.classList.contains('sf-drop-btn') && e.toElement.className=='sf-wrapper')
        ) {
        console.log('test1');
        // Prevent deleting drop buttons
    }else{
        console.log('test2');
        // First remove all drop buttons
        sf_app.remove_drop_buttons();
    }

    // Retrieve all possible parent elements such as columns and multi-parts
    var nodes = sf_app.get_parents(target, '.sf-inner');
    // If target can contain inner elements add it to the nodes object
    if(target.childNodes[0].childNodes[0].classList.contains('sf-inner')){
        if(!nodes) nodes = [];
        nodes.push(target.childNodes[0].childNodes[0]);
    }
    if(nodes){
        Object.keys(nodes).forEach(function(key) {
            var name = nodes[key].parentNode.parentNode.dataset.sfname;
            // Only add drop buttons if they don't exist yet
            if(!nodes[key].parentNode.querySelectorAll(':scope > .sf-drop-btn').length){
                // Add drop here class
                nodes[key].classList.add('sf-drop-here');
                // Add "Drop before" button
                var node  = document.createElement('div');
                node.className = 'sf-drop-btn sf-drop-before';
                node.dataset['sftooltip'] = 'Drop before '+super_create_form_i18n.elements[name].title;
                node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"before"}}}';
                nodes[key].parentNode.appendChild(node);
                // Add "Drop inside" button
                var node  = document.createElement('div');
                node.className = 'sf-drop-btn sf-drop-inside';
                node.dataset['sftooltip'] = 'Drop inside '+super_create_form_i18n.elements[name].title;
                node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"inside"}}}';
                nodes[key].parentNode.appendChild(node);
                // Add "Drop after" button
                var node  = document.createElement('div');
                node.className = 'sf-drop-btn sf-drop-after';
                node.dataset['sftooltip'] = 'Drop after '+super_create_form_i18n.elements[name].title;
                node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"after"}}}';
                nodes[key].parentNode.appendChild(node);
            }
        });
    }
    // Retrieve all elements without possible inner elements
    var nodes = sf_app.get_parents(target, '.sf-element');
    if(nodes){
        Object.keys(nodes).forEach(function(key) {
            if(!nodes[key].querySelector('.sf-wrapper > .sf-inner')){
                // Only add drop buttons if they don't exist yet
                if(!nodes[key].querySelector('.sf-drop-btn')){
                    var name = nodes[key].dataset.sfname;
                    // Add drop here class
                    nodes[key].classList.add('sf-drop-here');
                    // Add "Drop before" button
                    var node  = document.createElement('div');
                    node.className = 'sf-drop-btn sf-drop-before';
                    node.dataset['sftooltip'] = 'Drop before '+super_create_form_i18n.elements[name].title+' field';
                    node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"before"}}}';
                    nodes[key].appendChild(node);
                    // Add "Drop after" button
                    var node  = document.createElement('div');
                    node.className = 'sf-drop-btn sf-drop-after';
                    node.dataset['sftooltip'] = 'Drop after '+super_create_form_i18n.elements[name].title+' field';
                    node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"after"}}}';
                    nodes[key].appendChild(node);
                }
            }
        });
    }

    //console.log(e.fromElement.className, ' / ', e.toElement.className);

    /*
    if( (e.fromElement && e.toElement) && (
        //(e.fromElement.classList.contains('sf-inner') && e.toElement.classList.contains('sf-inner')) ||
        (e.fromElement.classList.contains('sf-drop-btn') && e.toElement.classList.contains('sf-inner')) ||
        (e.fromElement.classList.contains('sf-wrapper') && e.toElement.classList.contains('sf-inner')) ||
        (e.fromElement.classList.contains('sf-element') && e.toElement.classList.contains('sf-inner')) ||
        (e.fromElement.classList.contains('sf-inner') && (!e.fromElement.classList.contains('sf-drop-here')) && e.toElement.classList.contains('sf-wrapper')) ||
        (e.fromElement.classList.contains('sf-inner') && e.toElement.classList.contains('sf-element')) 


        ) 
    ){
        // Prevent deleting drop buttons
        //console.log(e);
    }else{
        console.log(e.fromElement.className, ' / ', e.toElement.className);
        console.log(e);
        // First remove all drop buttons
        sf_app.remove_drop_buttons();
        return false;
    }

    // Retrieve all possible parent elements such as columns and multi-parts
    var nodes = sf_app.get_parents(target, '.sf-inner');
    // If target can contain inner elements add it to the nodes object
    if(target.childNodes[0].childNodes[0].classList.contains('sf-inner')){
        if(!nodes) nodes = [];
        nodes.push(target.childNodes[0].childNodes[0]);
    }
    if(nodes){
        Object.keys(nodes).forEach(function(key) {
            var name = nodes[key].parentNode.parentNode.dataset.sfname;
            // Only add drop buttons if they don't exist yet
            if(!nodes[key].parentNode.querySelectorAll(':scope > .sf-drop-btn').length){
                // Add drop here class
                nodes[key].classList.add('sf-drop-here');
                // Add "Drop before" button
                var node  = document.createElement('div');
                node.className = 'sf-drop-btn sf-drop-before';
                node.dataset['sftooltip'] = 'Drop before '+super_create_form_i18n.elements[name].title;
                node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"before"}}}';
                nodes[key].parentNode.appendChild(node);
                // Add "Drop inside" button
                var node  = document.createElement('div');
                node.className = 'sf-drop-btn sf-drop-inside';
                node.dataset['sftooltip'] = 'Drop inside '+super_create_form_i18n.elements[name].title;
                node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"inside"}}}';
                nodes[key].parentNode.appendChild(node);
                // Add "Drop after" button
                var node  = document.createElement('div');
                node.className = 'sf-drop-btn sf-drop-after';
                node.dataset['sftooltip'] = 'Drop after '+super_create_form_i18n.elements[name].title;
                node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"after"}}}';
                nodes[key].parentNode.appendChild(node);
            }
        });
    }

    // Retrieve all elements without possible inner elements
    var nodes = sf_app.get_parents(target, '.sf-element');
    if(nodes){
        Object.keys(nodes).forEach(function(key) {
            if(!nodes[key].querySelector('.sf-wrapper > .sf-inner')){
                // Only add drop buttons if they don't exist yet
                if(!nodes[key].querySelector('.sf-drop-btn')){
                    var name = nodes[key].dataset.sfname;
                    // Add drop here class
                    nodes[key].classList.add('sf-drop-here');
                    // Add "Drop before" button
                    var node  = document.createElement('div');
                    node.className = 'sf-drop-btn sf-drop-before';
                    node.dataset['sftooltip'] = 'Drop before '+super_create_form_i18n.elements[name].title+' field';
                    node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"before"}}}';
                    nodes[key].appendChild(node);
                    // Add "Drop after" button
                    var node  = document.createElement('div');
                    node.className = 'sf-drop-btn sf-drop-after';
                    node.dataset['sftooltip'] = 'Drop after '+super_create_form_i18n.elements[name].title+' field';
                    node.dataset['sfactions'] = '{"mouseover":{"tooltip.show":{"position":"bottom"}},"click":{"drop":{"method":"after"}}}';
                    nodes[key].appendChild(node);
                }
            }
        });
    }
    */

};

// Get total items of an object
sf_app.obj_total = function(obj){
    var total = 0;
    Object.keys(obj).forEach(function(key) {
        total++;
    });
    return total;
}

// Update form width 
sf_app.append_px_unit = function(value){
    if( !isNaN(value) ) {
        // The value does not contain a unit yet, let's append 'px' to it
        return value.replace('px','').trim()+'px';
    }
    return value;
}

sf_app.form_data = function(){
    var data = sessionStorage.getItem('sf_form_data');
    if(data){
        return JSON.parse(data);
    }else{
        data = {
            parts : [
                {
                    settings : {
                        title : super_create_form_i18n.Title,
                        desc : super_create_form_i18n.Description,
                        next : super_create_form_i18n.Next,
                        prev : super_create_form_i18n.Previous
                    },
                    elements : []
                    /*
                        {
                            text : {
                                name : super_create_form_i18n.field,
                                placeholder : super_create_form_i18n.Dummy_placeholder,
                                label : super_create_form_i18n.Dummy_label
                            }
                        }
                    ]
                    */
                }
            ],
            settings : {},
            theme : {
                form : {
                    width : {
                        size: '100%'
                    },
                    bg_color : "#fff",
                    padding : {
                        top : "0",
                        right : "0",
                        bottom : "0",
                        left : "0"
                    },
                    margin : {
                        top : "0",
                        right : "0",
                        bottom : "0",
                        left : "0"
                    },
                    border : {
                        top : {
                            size : "0",
                            color : "",
                            style : "solid"
                        },
                        right : {
                            size : "0",
                            color : "",
                            style : "solid"
                        },
                        bottom : {
                            size : "0",
                            color : "",
                            style : "solid"
                        },
                        left : {
                            size : "0",
                            color : "",
                            style : "solid"
                        }
                    }
                }
            },
            triggers : [
                {
                    on : "submit",
                    action : "send_mail",
                    priority : "0",
                    to : "feeling4design@gmail.com",
                    from_email : "no-reply@f4d.nl",
                    from_name : "My site title",
                    subject : "New request",
                    conditions : {}
                },
                {
                    on : "submit",
                    action : "send_mail",
                    priority : "0",
                    to : "feeling4design@gmail.com",
                    from_email : "no-reply@f4d.nl",
                    from_name : "My site title",
                    subject : "We received your request!",
                    conditions : {}
                }
            ]
        };
        sessionStorage.setItem('sf_form_data', JSON.stringify(data));
        return data;
    }
};

// Clear the form
sf_app.clear = function(e, target){
    // Grab form data
    var data = sf_app.form_data();
    // Loop through parts, and remove all parts except for the first part
    Object.keys(data.parts).forEach(function(key){
        if(key==0){
            // Set elements to empty array
            data.parts[key].elements = [];            
        }else{
            // Completely remove
            data = jsonpatch.applyOperation(data, { op: "remove", path: '/parts/'+key }).newDocument;
        }
    });
    // Update local storage
    sf_app.save_form_data(data);
    // Generate canvas
    sf_app.rebuild_canvas(data.parts);
    // Close edit panel
    sf_app.edit_panel.close();
    // Remove active class on item in elements list
    sf_app.remove_class(sf_app.qa('.sf-item.sf-active'), 'sf-active' );
    // Remove moving and dropping state
    sf_app.remove_class(sf_app.qa('.sf-moving'), 'sf-moving' );
    sf_app.remove_class(sf_app.qa('.sf-dropping'), 'sf-dropping' );
    // Remove breadcrumb
    sf_app.breadcrumb.delete();
};

// Undo Redo last change (history)
sf_app.undo_redo = function(e, target){
    if(target.classList.contains('sf-disabled')){
        return true;
    }
    var history = sessionStorage.getItem('sf_form_history');
    if(history){
        history = JSON.parse(history);
        var total_history = sf_app.obj_total(history);
        var index = parseFloat(target.dataset['index']);
        if(target.classList.contains('sf-undo')){
            index = index-1;
        }else{
            index = index+1;
        }
        //console.log(index);
        var parts = history[index];
        // Rebuild canvas based on history data
        sf_app.rebuild_canvas(parts);
        // Save form data based on history data
        var data = sessionStorage.getItem('sf_form_data');
        data = JSON.parse(data);
        data.parts = parts;
        sessionStorage.setItem('sf_form_data', JSON.stringify(data));
        // Enable the redo button
        if(target.classList.contains('sf-undo')){
            var other = sf_app.q('.sf-redo');
        }else{
            var other = sf_app.q('.sf-undo');
        }
        other.classList.remove('sf-disabled');
        if(target.classList.contains('sf-undo')){
            // Add correct indexes to the undo/redo buttons
            if(index-1 < 0){
                target.classList.add('sf-disabled');
            }else{
                target.classList.remove('sf-disabled');
            }
        }else{
            if(index >= total_history-1){
                target.classList.add('sf-disabled');
            }else{
                target.classList.remove('sf-disabled');
            }
        }
        other.dataset['index'] = index;
        target.dataset['index'] = index;
    }
}

// Save form data in local storage
sf_app.save_form_data = function(data, update_navigator){
    if(typeof update_navigator === 'undefined') var update_navigator = true;
    // Convert data object to json string
    var json = JSON.stringify(data);
    // Before saving the form data, add it to form history for our Undo and Redo functionality
    var history = sessionStorage.getItem('sf_form_history');
    if(history){
        history = JSON.parse(history);
        // History already exists, push form data to the history object
        history.push(data.parts);
    }else{
        // Get current data
        var current_data = sessionStorage.getItem('sf_form_data');
        current_data = JSON.parse(current_data);
        // Update form history
        var history = [];
        history.push(current_data.parts);
        history.push(data.parts);
    }

    // Disable buttons
    var total_history = sf_app.obj_total(history),
        undo = sf_app.q('.sf-undo'),
        redo = sf_app.q('.sf-redo');
    undo.dataset['index'] = total_history-1;
    redo.dataset['index'] = total_history-1;
    redo.classList.add('sf-disabled');
    if(total_history<=1){
        undo.classList.add('sf-disabled');
    }else{
        undo.classList.remove('sf-disabled');
    }
    // Update form history
    sessionStorage.setItem('sf_form_history', JSON.stringify(history));
    // Update form data
    sessionStorage.setItem('sf_form_data', json);
    // Update navigator list
    if(update_navigator){
        sf_app.navigator.update(data.parts);
    }
}

// Update form width 
sf_app.update_form_width = function(e, target){
    var data = sf_app.form_data(),
        value;
    if(!target){
        value = data.theme.form.width.size;
    }else{
        value = sf_app.append_px_unit(target.value);
        data.theme.form.width.size = value;
        // Update local storage
        sf_app.save_form_data(data);
    }
    sf_app.q('.sf-canvas-wrapper').style.width = value;
}

// Add new step (Multi-part)
sf_app.add_multipart_step = function(e, target){

    // Grab current form data
    var data = sf_app.form_data();

    var total = sf_app.obj_total(sf_app.form_data().parts)+1;
    var new_part = {
        settings : {
            title : "Title",
            desc : "Description",
            next : "Next",
            prev : "Previous"
        },
        elements : []
    };

    // Add new part to the form data
    data.parts.push(new_part);

    // If total parts is 2 or more, then we need to add the steps and the progress bar
    if(total>=2){
        sf_app.generate_multipart_steps(data.parts, total);
        sf_app.generate_multipart_progressbar(total);
    }

    // Remove active class from parts
    var parts = sf_app.qa('.sf-form .sf-drop-area');
    Object.keys(parts).forEach(function(key) {
        parts[key].classList.remove('sf-active');
    });

    // Create drop area for this part
    var node  = document.createElement('div');
    node.classList.add('sf-drop-area');
    node.classList.add('sf-active');
    sf_app.q('.sf-form').appendChild(node);

    // Remove active class from steps
    var steps = sf_app.q('.sf-multipart-steps').children;
    var total_steps = 0;
    Object.keys(steps).forEach(function(key) {
        steps[key].classList.remove('sf-active');
        total_steps++;
    });
    steps[total_steps-1].classList.add('sf-active');

    // Update progress bar progress
    var progress = 100 / total_steps;
    progress = progress * (total_steps);
    sf_app.q('.sf-multipart-progress-bar').style.width = progress+'%';

    // Update local storage
    sf_app.save_form_data(data);
}

// Delete step (Multi-part)
sf_app.delete_multipart_step = function(e, target){
    // Let's get the active part, and delete it
    var active_part = sf_app.q('.sf-multipart-step.sf-active');
    var index = sf_app.index(active_part);
    
    // Also delete the part from the form data object
    // We use splice, because we want to keep a nice index order
    // This also prevents from having a "null" value
    var data = sf_app.form_data();
    data.parts.splice(index,1);

    var total = sf_app.obj_total(data.parts);
    sf_app.generate_multipart_steps(data.parts, total);
    sf_app.generate_multipart_progressbar(total, index);

    if(total>1){
        // Remove active class from steps
        var steps = sf_app.q('.sf-multipart-steps').children;
        Object.keys(steps).forEach(function(key) {
            steps[key].classList.remove('sf-active');
        });

        // Make previous step active
        if(typeof sf_app.q('.sf-multipart-steps').children[index-1] !== 'undefined'){
            sf_app.q('.sf-multipart-steps').children[index-1].classList.add('sf-active');
        }else{
            sf_app.q('.sf-multipart-steps').children[0].classList.add('sf-active');
        }
    }

    // Also remove active drop area
    sf_app.q('.sf-drop-area.sf-active').remove();
    
    // Make previous drop area active
    var parts = sf_app.qa('.sf-form .sf-drop-area');
    Object.keys(parts).forEach(function(key) {
        parts[key].classList.remove('sf-active');
    });
    if(index==0)  index++;
    if(typeof sf_app.q('.sf-form').children[index] !== 'undefined'){
        sf_app.q('.sf-form').children[index].classList.add('sf-active');
    }else{
        sf_app.q('.sf-form').children[1].classList.add('sf-active');
    }

    // Update local storage
    sf_app.save_form_data(data);
}


// Generate Multi-part Steps
sf_app.generate_multipart_steps = function(parts, total_parts){
    if(total_parts>1){
        
        // Show multi-part delete button
        sf_app.q('.sf-delete-multipart-step').style.display = null;

        sf_app.q('.sf-multipart').classList.add('sf-active');
        var html  = '';
        var counter = 1;
        Object.keys(parts).forEach(function(key) {
            var part = parts[key];
            var sfaction = ' data-sfactions=\'{"click":{"multipart_step_click":{}}}\'';
            if(total_parts==1){
                html += '<li class="sf-multipart-step sf-active sf-last-step"'+sfaction+'>';
            }else{
                if((key==0) && (total_parts != (key+1))){
                    html += '<li class="sf-multipart-step sf-active"'+sfaction+'>';
                }else{
                    if(total_parts == (key+1)){
                        html += '<li class="sf-multipart-step sf-last-step"'+sfaction+'>';
                    }else{
                        html += '<li class="sf-multipart-step"'+sfaction+'>';
                    }
                }
            }
            html += '<span class="sf-multipart-step-wrapper">';
            if(typeof part.icon !== 'undefined' && part.icon!='') {
                html += '<span class="sf-multipart-step-icon"><i class="fa fa-'+part.icon+'"></i></span>';
            }
            html += '<span class="sf-multipart-step-count">'+counter+'</span>';
            if(typeof part.title !== 'undefined' && part.title!='') {
                html += '<span class="sf-multipart-step-name">'+part.title+'</span>';
            }
            if(typeof part.desc !== 'undefined' && part.desc!='') {
                html += '<span class="sf-multipart-step-description">'+part.desc+'</span>';
            }
            html += '</span>';
            html += '</li>';
            counter++;
        });
        sf_app.q('.sf-multipart-steps').innerHTML = html;
    }else{
        // Delete the multi-part steps
        sf_app.q('.sf-multipart').classList.remove('sf-active');
        sf_app.q('.sf-multipart-steps').innerHTML = '';

        // Delete the multi-part progress bar
        if(sf_app.q('.sf-multipart-progress-inner')){
            sf_app.q('.sf-multipart-progress-inner').remove();
        }

        // Delete multi-part delete button
        sf_app.q('.sf-delete-multipart-step').style.display = 'none';
    }
}

// Generate Multi-part Progress Bar
sf_app.generate_multipart_progressbar = function(total_parts, index){
    if(total_parts>1){
        var progress = 100 / total_parts;
        // Only generate progress bar if it doesn't exist yet
        if(!sf_app.q('.sf-multipart-progress-inner')){
            // Generate progress bar
            var html = '<div class="sf-multipart-progress-inner">';
            html += '<div class="sf-multipart-progress-bar" style="width:'+progress+'%"></div>';
            html += '</div>';
            sf_app.q('.sf-multipart-progress').innerHTML = html;
        }
        if(index){
            // Update progress bar progress
            var progress = 100 / total_parts;
            progress = progress * (index);
            sf_app.q('.sf-multipart-progress-bar').style.width = progress+'%';
        }
    }
}

// Switch from multi-part
sf_app.multipart_step_click = function(e, target){
    var index =  sf_app.index(target);

    // Remove active class from steps
    var steps = sf_app.q('.sf-multipart-steps').children;
    var total_steps = 0;
    Object.keys(steps).forEach(function(key) {
        steps[key].classList.remove('sf-active');
        total_steps++;
    });
    target.classList.add('sf-active');

    // Remove active class from parts
    var parts = sf_app.qa('.sf-form .sf-drop-area');
    Object.keys(parts).forEach(function(key) {
        parts[key].classList.remove('sf-active');
    });
    sf_app.q('.sf-form').children[index+1].classList.add('sf-active');
    
    // Update progress bar progress
    var progress = 100 / total_steps;
    progress = progress * (index+1);
    sf_app.q('.sf-multipart-progress-bar').style.width = progress+'%';

    // Update navigator list
    sf_app.navigator.update();
}


// Remove any CSS stylesheets
var i = 0;
[].forEach.call(document.styleSheets, function(el) {
    if(el.href){
        //if(el.href.indexOf('super-forms/assets/css')!=-1){
            //document.styleSheets[i].disabled = true;
        //} 
    }
    i++;
});

// Scroll elements horizontally
function sf_scroll_horizontally(e) {
    e = window.event || e;
    var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
    sf_app.q('.sf-elements .sf-items-wrapper').scrollLeft -= (delta*100); // Multiplied by 40
    e.preventDefault();
}
if (sf_app.q('.sf-elements .sf-items-wrapper').addEventListener) {
    var supportsPassive = false;
    try {
        var opts = Object.defineProperty({}, 'passive', {
            get: function() {
                supportsPassive = true;
            }
        });
        window.addEventListener("testPassive", null, opts);
        window.removeEventListener("testPassive", null, opts);
    } catch (e) {}

    sf_app.q('.sf-elements .sf-items-wrapper').addEventListener('mousewheel', sf_scroll_horizontally, supportsPassive ? { passive: false } : false); // IE9, Chrome, Safari, Opera
    sf_app.q('.sf-elements .sf-items-wrapper').addEventListener('DOMMouseScroll', sf_scroll_horizontally, supportsPassive ? { passive: false } : false); // Firefox
} else {
    sf_app.q('.sf-elements .sf-items-wrapper').attachEvent('onmousewheel', sf_scroll_horizontally); // IE 6/7/8
}


//function lengthInUtf8Bytes(str) {
//  // Matches only the 10.. bytes that are non-initial characters in a multi-byte sequence.
//  var m = encodeURIComponent(str).match(/%[89ABab]/g);
//  return str.length + (m ? m.length : 0);
//}
//var $megabytes = lengthInUtf8Bytes($json)/1000000;
//console.log('megabytes: '+$megabytes);
console.log(super_create_form_i18n);

sf_app.rebuild_canvas = function(parts){

    // Generate multi-part steps
    var total_parts = sf_app.obj_total(parts);

    // Generate multi-part steps
    if(total_parts>1){
        sf_app.generate_multipart_steps(parts, total_parts);
        sf_app.generate_multipart_progressbar(total_parts);
    }else{
        // Empty the multi-part and hide it if we have to
        sf_app.q('.sf-multipart').classList.remove('sf-active');
        sf_app.q('.sf-delete-multipart-step').style.display = 'none';
    }

    // Delete all drop areas
    var nodes = sf_app.qa('.sf-drop-area');
    Object.keys(nodes).forEach(function(key) {
        nodes[key].remove();
    });

    // Create elements, and add them to their corresponding part (drop area)
    Object.keys(parts).forEach(function(key) {
        var part = parts[key];

        // Create drop area for this part
        var node  = document.createElement('div');
        node.classList.add('sf-drop-area');
        if(key==0){
            node.classList.add('sf-active');
        }

        // Generate elements HTML and append it to the part
        var html = '';
        Object.keys(part.elements).forEach(function(key) {
            var data = part.elements[key];
            Object.keys(data).forEach(function(k) {
                var settings = data[k].settings,
                    inner = data[k].inner;
                html += sf_app.element_html(k, settings, inner);
            });
        });
        node.innerHTML = html;

        // Add droparea to the canvas
        sf_app.q('.sf-form').appendChild(node);
    });

    // Generate navigator list
    sf_app.navigator.update(parts);

};

// Initialize resizable/draggable navigator
jQuery(document).ready(function($){
    $('.sf-navigator').resizable({
        handles: "s, e, se"
    });
    $('.sf-navigator').draggable({
        handle: '.sf-header'
    });

    sf_app.navigator.init_sortable();
  
    /*   
    var containers = [];
    containers.push(document.querySelectorAll('.sf-sortable'));
    containers.push(document.querySelectorAll('.sf-sortable .sf-item'));
    .slice.apply(document.querySelectorAll('.sf-sortable'));
    containers.slice.apply(document.querySelectorAll('.sf-sortable .sf-item'));
    */

    //drake.on('drop',function(el, target, source, sibling){
    //    // el was dropped into target before a sibling element, and originally came from source
    //    alert('DROP');
    //    console.log(el, target, source, sibling);
    //});

});

// Load UI
(function() {
    // Set form width
    sf_app.update_form_width();
    var parts = sf_app.form_data().parts;
    // Rebuild canvas based on form data
    sf_app.rebuild_canvas(parts);
    // Remove disabled class from undo button if history exists
    var history = sessionStorage.getItem('sf_form_history');
    if(history){
        sf_app.q('.sf-undo').classList.remove('sf-disabled');
        history = JSON.parse(history);
        var total_history = sf_app.obj_total(history);
        sf_app.q('.sf-undo').dataset['index'] = total_history-1;
    }
    // Remove loading class
    setTimeout(function(){
        sf_app.q('.sf-builder').classList.remove('loading');
    },500);
})();

// Equivalent for jQuery's .on() function
sf_app.delegate = function(element, event, elements, callback) {
    element.addEventListener(event, function(event) {
        var target = event.target;
        while (target && target !== this) {
            if (target.matches(elements)) {
                callback(event, target);
                return false;
            }
            target = target.parentNode;
        }
    });
};

sf_app.events = {
    keyup : [
        '.sf-canvas-width-fields input'
    ],
    click : [
        'body',
        '.sf-multipart-step',
        '.sf-add-multipart-step',
        '.sf-undo',
        '.sf-redo',
        '.sf-delete-multipart-step',
        '.sf-items .sf-item',
        '.sf-drop-btn',
        '.sf-drop-area.sf-active .sf-element',
        '.sf-breadcrumb li',
        '.sf-breadcrumb li > span',
        '.sf-context-menu .sf-edit',
        '.sf-context-menu .sf-delete',
        '.sf-navigator .sf-close',
        '.sf-navigator .sf-list .sf-item',
        '.sf-navigator .sf-list .sf-item > .sf-toggle',
        '.sf-navigator .sf-list .sf-item > .sf-visibility',
    ],
    mouseover : [
        '.sf-dropping .sf-drop-area.sf-active .sf-element',
        '.sf-moving .sf-drop-area.sf-active .sf-element',
        '.sf-actions > div',
        '.sf-add-multipart-step',
        '.sf-undo',
        '.sf-redo',
        '.sf-clear',
        '.sf-delete-multipart-step',
        '.sf-breadcrumb li',
        '.sf-drop-btn',
        '.sf-navigator-toggle',
        '.sf-navigator .sf-list .sf-item'
    ],
    mouseout : [
        '.sf-actions > div',
        '.sf-add-multipart-step',
        '.sf-undo',
        '.sf-redo',
        '.sf-clear',
        '.sf-delete-multipart-step',
        '.sf-breadcrumb li',
        '.sf-drop-btn',
        '.sf-navigator-toggle',
        '.sf-navigator .sf-list .sf-item',
    ],
    contextmenu : [
        'body',
        '.sf-drop-area.sf-active .sf-element'
    ],
    oncontextmenu : [
        'body',
        '.sf-drop-area.sf-active .sf-element'
    ]
    //input : [
    //],
    //blur : [
    //]
};


// Iterate over all events, and listen to any event being triggered
Object.keys(sf_app.events).forEach(function(event) {
    var elements = sf_app.events[event].join(", ");
    sf_app.delegate(document, event, elements, function(e, target){
        //console.log(event);
        //console.log(target);
        //console.log(e.target);
        if(typeof e.target.dataset.sfactions !== 'undefined'){
            var target = e.target;
        }
        if(event=='mouseout'){
            // First close any other tooltip
            sf_app.tooltip.close();
        }
        if(typeof target.dataset.sfactions !== 'undefined'){
            var actions = JSON.parse(target.dataset.sfactions)[event];
            if(actions){
                Object.keys(actions).forEach(function(key) { // key = function name
                    var _function = key.split('.');
                    if(_function.length>1){
                        sf_app[_function[0]][_function[1]](e, target, event, actions[key]); // actions[key] = function parameters
                    }else{
                        sf_app[_function[0]](e, target, event, actions[key]); // actions[key] = function parameters
                    }
                });
            }
        }
        if(event=='click'){
            if(!sf_app.in_path(e, 'sf-context-menu')){
                // Close context menu
                sf_app.context_menu.close();
            }
        }
        if(event=='contextmenu' || event=='oncontextmenu'){
            if(target.classList.contains('sf-element')){
                // Remove highlight class from all highlighted elements
                sf_app.remove_class(sf_app.qa('.sf-element.sf-highlighted'), 'sf-highlighted' );
                // Open context menu
                sf_app.context_menu.open(target);
                e.preventDefault();
                window.event.returnValue = false;
                return false;
            }else{
                if(target.closest('.sf-breadcrumb')){
                    // Open context menu
                    sf_app.context_menu.open(target);
                    e.preventDefault();
                    window.event.returnValue = false;
                    return false;
                }else{
                    if(!sf_app.in_path(e, 'sf-context-menu')){
                        // Close context menu
                        sf_app.context_menu.close();
                    }
                }
            }
        }

        /*
        if(event=='click'){
            if(!sf_app.in_path(e, 'sf-context-menu')){
                // Close context menu
                sf_app.context_menu.close();
            }
        }
        if(event=='contextmenu' || event=='oncontextmenu'){
            if(target.classList.contains('sf-element')){
                // Remove highlight class from all highlighted elements
                var highlighted = sf_app.qa('.sf-drop-area.sf-active .sf-element.sf-highlighted');
                for (var key = 0; key < highlighted.length; key++) {
                    highlighted[key].classList.remove('sf-highlighted');
                }
                // Highlight element
                target.classList.add('sf-highlighted');
                // Open context menu
                sf_app.context_menu.open();
                e.preventDefault();
                window.event.returnValue = false;
                return false;
            }else{
                console.log('test');
                console.log(e);

                if(sf_app.in_path(e, 'sf-context-menu')){
                    console.log('test2');
                    // Do nothing!
                }else{
                    console.log('test3');
                    // Close context menu
                    sf_app.context_menu.close();
                }
            }
        }
        if(event=='mouseover' || event=='mouseout'){
            if(typeof target.dataset.sftooltip !== 'undefined'){
                // First remove any other tooltip
                if(sf_app.q('.sf-tooltipper')){
                    sf_app.q('.sf-tooltipper').remove();
                }
                if(event=='mouseover'){
                    // Create tooltip 
                    var node  = document.createElement('div');
                    node.classList.add('sf-tooltipper');
                    node.innerHTML = target.dataset.sftooltip;

                    // Get the position relative to the viewport (i.e. the window)
                    var offset = target.getBoundingClientRect();
                    var target_absolute_position_left = offset.left+(offset.width/2);
                    //var margins = getComputedStyle(target);
                    //var target_height = target.offsetHeight + parseInt(margins.marginTop) + parseInt(margins.marginBottom);
                    var w = window,
                        d = document,
                        e = d.documentElement,
                        g = d.getElementsByTagName('body')[0],
                        window_width = w.innerWidth || e.clientWidth || g.clientWidth,
                        window_height = w.innerHeight|| e.clientHeight|| g.clientHeight;

                    node.style.position = 'absolute';
                    node.style.top = 0;
                    node.style.left = 0;

                    // Append the node
                    sf_app.q('body').appendChild(node);
                    var initial_width = node.offsetWidth;

                    if(typeof target.dataset.sftooltipPosition === 'undefined'){
                        node.style.top = offset.top+'px';
                        node.style.transform = 'translateX(-50%) translateY(-150%)';
                    }
                    if(typeof target.dataset.sftooltipPosition !== 'undefined'){
                        node.classList.add('sf-bottom');
                        node.style.top = offset.top+(offset.height)+'px';
                        node.style.transform = 'translateX(-50%) translateY(50%)';
                    }
                    node.style.left = target_absolute_position_left+'px';
                    
                    // Check if we can't position the element at top or bottom because of overlapping window
                    // The tooltip could possibly be cut off if we do not check this
                    if(window_width < target_absolute_position_left+initial_width){
                        // We have to position the tooltip to the left side of the target
                        node.style.transform = null;
                        node.style.left = (offset.left-initial_width-30)+'px';
                        node.classList.remove('sf-bottom');
                        node.classList.add('sf-left');
                    }


                }
                return false;
            }
        }
        if(typeof target.dataset.sfaction !== 'undefined'){
            if(sf_app.q('.sf-tooltipper')){
                sf_app.q('.sf-tooltipper').remove();
            }
            console.log(target.dataset.sfaction);
            if(target.dataset.sfaction.indexOf(';')!==-1){
                var action = target.dataset.sfaction.split(';'),
                function_name = action[0],
                element_name = action[1];
                sf_app[function_name](e, target, element_name, event);
            }else{
                sf_app[target.dataset.sfaction](e, target);
            }
        }
        */
    });
});
