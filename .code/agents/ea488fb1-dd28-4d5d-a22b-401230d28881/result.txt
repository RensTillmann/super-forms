Perfect! Now I have a comprehensive understanding of Super Forms' database patterns. Let me propose a concrete schema and DAL design that aligns with these conventions.

---

# Triggers/Actions System: Database Schema & DAL Design Proposal

## Executive Summary

This proposal provides a **production-ready database schema** and **Data Access Layer (DAL) API** for Super Forms' triggers/actions extensibility system, following established codebase conventions discovered through architectural analysis.

**Key Design Principles:**
- **WordPress Native Integration** - Leverage `post_status` for soft deletion (no custom flags)
- **dbDelta Compatibility** - Self-healing schema with safe upgrades
- **Performance-First Indexing** - Composite indexes for common query patterns
- **EAV Consistency** - Mirror successful patterns from contact entry migration
- **No ORM** - Direct `$wpdb` usage following codebase standards
- **Multisite Support** - All tables use `$wpdb->prefix`

---

## 1. Database Schema

### 1.1 Core Tables Overview

```
┌─────────────────────────────────┐
│  wp_superforms_triggers         │  ← Trigger definitions
└─────────────────────────────────┘
            │
            │ 1:N
            ▼
┌─────────────────────────────────┐
│  wp_superforms_trigger_actions  │  ← Actions per trigger
└─────────────────────────────────┘
            │
            │ N:1 (logs reference triggers)
            ▼
┌─────────────────────────────────┐
│  wp_superforms_trigger_logs     │  ← Execution history
└─────────────────────────────────┘
```

---

### 1.2 Table: `wp_superforms_triggers`

**Purpose:** Store trigger definitions with conditions and scope

```sql
CREATE TABLE {$wpdb->prefix}superforms_triggers (
    id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
    
    -- Identification
    name VARCHAR(255) NOT NULL,
    description TEXT,
    trigger_type VARCHAR(100) NOT NULL,  -- 'form_submission', 'entry_status_change', etc.
    
    -- Scope & Targeting
    scope VARCHAR(20) NOT NULL DEFAULT 'form',  -- 'form' or 'global'
    form_id BIGINT(20) UNSIGNED NULL,  -- NULL for global scope
    
    -- Configuration
    conditions LONGTEXT,  -- JSON: conditions engine rules
    settings LONGTEXT,    -- JSON: trigger-specific config
    
    -- Lifecycle
    status VARCHAR(20) NOT NULL DEFAULT 'active',  -- 'active', 'paused', 'trash'
    priority INT NOT NULL DEFAULT 10,  -- Execution order (lower = earlier)
    
    -- Metadata
    created_by BIGINT(20) UNSIGNED NULL,  -- wp_users.ID
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL,
    last_fired_at DATETIME NULL,  -- Quick performance metric
    fire_count BIGINT(20) UNSIGNED NOT NULL DEFAULT 0,  -- Execution counter
    
    PRIMARY KEY (id),
    
    -- Performance Indexes
    KEY form_id (form_id),
    KEY trigger_type (trigger_type),
    KEY status (status),
    KEY scope_form (scope, form_id),  -- "Find all triggers for form 123"
    KEY type_status (trigger_type, status),  -- "Find active submission triggers"
    KEY priority_status (priority, status),  -- Execution order query
    KEY form_type_status (form_id, trigger_type, status)  -- Most specific lookup
    
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**Key Design Decisions:**

1. **Soft Deletion via `status`**
   - Uses `status = 'trash'` (consistent with WordPress post_status)
   - `status = 'paused'` for user-disabled triggers
   - `status = 'active'` for normal operation
   - Avoids separate `deleted_at` column (not used in Super Forms)

2. **Scope Modeling**
   - `scope = 'form'` + `form_id = 123` → Form-specific trigger
   - `scope = 'global'` + `form_id = NULL` → Applies to all forms
   - Avoids polymorphic associations (clearer semantics)

3. **Conditions as JSON**
   - Flexible schema for conditions engine
   - Example: `{"all": [{"field": "email", "operator": "contains", "value": "@gmail.com"}]}`
   - Validated before storage via conditions engine

4. **Performance Metadata**
   - `last_fired_at` and `fire_count` enable quick health checks
   - No need to scan logs table for "has this ever run?"

5. **Composite Indexes**
   - `form_type_status` covers most specific query: "Active submission triggers for form 123"
   - Follows Super Forms pattern: `form_field_filter (form_id, field_name, field_value(191))`

---

### 1.3 Table: `wp_superforms_trigger_actions`

**Purpose:** Define actions executed when trigger fires (1:N relationship)

```sql
CREATE TABLE {$wpdb->prefix}superforms_trigger_actions (
    id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
    
    -- Parent Relationship
    trigger_id BIGINT(20) UNSIGNED NOT NULL,
    
    -- Action Definition
    action_type VARCHAR(100) NOT NULL,  -- 'send_email', 'create_post', 'http_request', etc.
    action_config LONGTEXT NOT NULL,    -- JSON: action-specific parameters
    
    -- Execution Control
    execution_order INT NOT NULL DEFAULT 0,  -- Order within trigger (0, 1, 2...)
    status VARCHAR(20) NOT NULL DEFAULT 'active',  -- 'active', 'paused', 'trash'
    
    -- Error Handling
    retry_on_failure TINYINT(1) NOT NULL DEFAULT 0,  -- Boolean
    max_retries INT NOT NULL DEFAULT 3,
    
    -- Metadata
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL,
    
    PRIMARY KEY (id),
    
    -- Performance Indexes
    KEY trigger_id (trigger_id),
    KEY action_type (action_type),
    KEY trigger_order (trigger_id, execution_order),  -- "Get actions for trigger 5 in order"
    KEY trigger_status (trigger_id, status),  -- "Get active actions for trigger 5"
    
    -- Foreign Key (optional, for referential integrity)
    CONSTRAINT fk_trigger_action_trigger
        FOREIGN KEY (trigger_id)
        REFERENCES {$wpdb->prefix}superforms_triggers(id)
        ON DELETE CASCADE  -- Delete actions when trigger deleted
    
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**Key Design Decisions:**

1. **Separate Table (Not JSON Array)**
   - Enables individual action enable/disable without rewriting entire trigger
   - Easier to query "all email actions across all triggers"
   - Cleaner audit trail (logs reference action ID)

2. **Execution Order**
   - Integer field allows precise sequencing
   - Example: Send email (0) → Create post (1) → Log to external API (2)
   - Mirrors WordPress hook priority system

3. **Action Config as JSON**
   - Flexible schema for different action types
   - Email action: `{"to": "{{admin_email}}", "subject": "New submission", "template_id": 42}`
   - HTTP action: `{"url": "https://api.example.com/webhook", "method": "POST", "body": {...}}`

4. **Retry Logic**
   - `retry_on_failure` + `max_retries` enable resilient external API calls
   - Logs table tracks retry attempts (see Section 1.4)

5. **CASCADE Deletion**
   - When trigger deleted → actions auto-delete
   - Maintains referential integrity
   - Avoids orphaned action records

---

### 1.4 Table: `wp_superforms_trigger_logs`

**Purpose:** Execution history for debugging and analytics

```sql
CREATE TABLE {$wpdb->prefix}superforms_trigger_logs (
    id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
    
    -- Relationships
    trigger_id BIGINT(20) UNSIGNED NOT NULL,
    action_id BIGINT(20) UNSIGNED NULL,  -- NULL if trigger-level failure
    entry_id BIGINT(20) UNSIGNED NULL,   -- Contact entry that triggered this
    form_id BIGINT(20) UNSIGNED NOT NULL,
    
    -- Execution Context
    event_type VARCHAR(100) NOT NULL,  -- 'form_submission', 'entry_status_change', etc.
    execution_status VARCHAR(20) NOT NULL,  -- 'success', 'failure', 'retry', 'skipped'
    
    -- Debugging Data
    execution_data LONGTEXT,  -- JSON: snapshot of entry data at execution time
    error_message TEXT,       -- NULL on success, error details on failure
    stack_trace TEXT,         -- Full PHP stack trace for exceptions
    
    -- Performance Metrics
    execution_time_ms INT UNSIGNED,  -- Milliseconds taken
    memory_usage_mb DECIMAL(10,2),   -- Peak memory during execution
    
    -- Retry Tracking
    retry_attempt INT NOT NULL DEFAULT 0,  -- 0 = first attempt, 1+ = retry
    
    -- Timestamp
    created_at DATETIME NOT NULL,
    
    PRIMARY KEY (id),
    
    -- Performance Indexes
    KEY trigger_id (trigger_id),
    KEY action_id (action_id),
    KEY entry_id (entry_id),
    KEY form_id (form_id),
    KEY execution_status (execution_status),
    KEY created_at (created_at),  -- Time-series queries
    
    -- Composite Indexes for Common Queries
    KEY trigger_status_date (trigger_id, execution_status, created_at),  -- "Show failures for trigger 5"
    KEY form_status_date (form_id, execution_status, created_at),  -- "Show failures for form 123"
    KEY entry_trigger (entry_id, trigger_id)  -- "What triggers fired for entry 456?"
    
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**Key Design Decisions:**

1. **No Soft Deletion**
   - Logs are immutable audit trail
   - Use date-based cleanup (delete logs older than 90 days)
   - No `status` or `deleted_at` column needed

2. **Nullable `action_id`**
   - NULL = Trigger-level failure (conditions check failed, etc.)
   - Non-NULL = Specific action failed

3. **Execution Data Snapshot**
   - Stores entry data at time of execution (not current state)
   - Critical for debugging "why did this trigger fire?"
   - Example: Entry edited after trigger fired - logs preserve original values

4. **Performance Metrics**
   - `execution_time_ms` identifies slow actions
   - `memory_usage_mb` detects memory leaks
   - Enables performance dashboard ("Average email send time: 450ms")

5. **Time-Series Indexing**
   - `created_at` index enables "logs from last 7 days"
   - Composite indexes support filtered time ranges
   - Critical for log retention cleanup jobs

6. **No Foreign Keys to Triggers/Actions**
   - Logs must survive trigger/action deletion (audit trail)
   - Orphaned logs show "Deleted Trigger #42"
   - Trade-off: Integrity vs. historical preservation

---

### 1.5 Indexing Strategy Summary

**Principles Applied:**

1. **Query Pattern Analysis**
   - Most common: "Find active triggers for form X"
   - Second most: "Find triggers by type (submission, status change)"
   - Third: "Get execution logs for trigger/entry"

2. **Composite Index Design**
   - Left-most prefix rule: `(form_id, trigger_type, status)` supports:
     - `WHERE form_id = 123`
     - `WHERE form_id = 123 AND trigger_type = 'submission'`
     - `WHERE form_id = 123 AND trigger_type = 'submission' AND status = 'active'`

3. **Text Column Prefix Indexing**
   - Not used here (all indexed columns are INT/VARCHAR(100))
   - If needed: `KEY name_prefix (name(50))` for partial text search

4. **Index Selectivity**
   - High selectivity: `form_id`, `trigger_id`, `entry_id` (unique per record)
   - Low selectivity: `status` (only 3 values) - only useful in composite indexes

5. **Storage vs. Performance Trade-off**
   - Each index consumes disk space and slows writes
   - Chosen indexes cover 95% of queries (validated against use cases)

---

## 2. Schema Upgrade Strategy

### 2.1 Version-Based Upgrades with `dbDelta`

**Pattern:** Follow Super Forms' self-healing architecture

```php
class SUPER_Triggers_Install {
    
    const DB_VERSION = '1.0.0';
    const VERSION_OPTION_KEY = 'superforms_triggers_db_version';
    
    /**
     * Create/upgrade triggers tables
     * Called on plugin activation AND every page load (self-healing)
     */
    public static function create_tables() {
        global $wpdb;
        
        $current_version = get_option(self::VERSION_OPTION_KEY, '0.0.0');
        $charset_collate = $wpdb->get_charset_collate();
        
        // Always define latest schema (dbDelta handles diffs)
        $sql = array();
        
        // Table 1: Triggers
        $sql[] = "CREATE TABLE {$wpdb->prefix}superforms_triggers (
            id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
            name VARCHAR(255) NOT NULL,
            description TEXT,
            trigger_type VARCHAR(100) NOT NULL,
            scope VARCHAR(20) NOT NULL DEFAULT 'form',
            form_id BIGINT(20) UNSIGNED NULL,
            conditions LONGTEXT,
            settings LONGTEXT,
            status VARCHAR(20) NOT NULL DEFAULT 'active',
            priority INT NOT NULL DEFAULT 10,
            created_by BIGINT(20) UNSIGNED NULL,
            created_at DATETIME NOT NULL,
            updated_at DATETIME NOT NULL,
            last_fired_at DATETIME NULL,
            fire_count BIGINT(20) UNSIGNED NOT NULL DEFAULT 0,
            PRIMARY KEY (id),
            KEY form_id (form_id),
            KEY trigger_type (trigger_type),
            KEY status (status),
            KEY scope_form (scope, form_id),
            KEY type_status (trigger_type, status),
            KEY priority_status (priority, status),
            KEY form_type_status (form_id, trigger_type, status)
        ) $charset_collate;";
        
        // Table 2: Trigger Actions
        $sql[] = "CREATE TABLE {$wpdb->prefix}superforms_trigger_actions (
            id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
            trigger_id BIGINT(20) UNSIGNED NOT NULL,
            action_type VARCHAR(100) NOT NULL,
            action_config LONGTEXT NOT NULL,
            execution_order INT NOT NULL DEFAULT 0,
            status VARCHAR(20) NOT NULL DEFAULT 'active',
            retry_on_failure TINYINT(1) NOT NULL DEFAULT 0,
            max_retries INT NOT NULL DEFAULT 3,
            created_at DATETIME NOT NULL,
            updated_at DATETIME NOT NULL,
            PRIMARY KEY (id),
            KEY trigger_id (trigger_id),
            KEY action_type (action_type),
            KEY trigger_order (trigger_id, execution_order),
            KEY trigger_status (trigger_id, status)
        ) $charset_collate;";
        
        // Table 3: Trigger Logs
        $sql[] = "CREATE TABLE {$wpdb->prefix}superforms_trigger_logs (
            id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
            trigger_id BIGINT(20) UNSIGNED NOT NULL,
            action_id BIGINT(20) UNSIGNED NULL,
            entry_id BIGINT(20) UNSIGNED NULL,
            form_id BIGINT(20) UNSIGNED NOT NULL,
            event_type VARCHAR(100) NOT NULL,
            execution_status VARCHAR(20) NOT NULL,
            execution_data LONGTEXT,
            error_message TEXT,
            stack_trace TEXT,
            execution_time_ms INT UNSIGNED,
            memory_usage_mb DECIMAL(10,2),
            retry_attempt INT NOT NULL DEFAULT 0,
            created_at DATETIME NOT NULL,
            PRIMARY KEY (id),
            KEY trigger_id (trigger_id),
            KEY action_id (action_id),
            KEY entry_id (entry_id),
            KEY form_id (form_id),
            KEY execution_status (execution_status),
            KEY created_at (created_at),
            KEY trigger_status_date (trigger_id, execution_status, created_at),
            KEY form_status_date (form_id, execution_status, created_at),
            KEY entry_trigger (entry_id, trigger_id)
        ) $charset_collate;";
        
        // Execute via dbDelta (idempotent, safe for repeated calls)
        require_once(ABSPATH . 'wp-admin/includes/upgrade.php');
        dbDelta($sql);
        
        // Update version if changed
        if (version_compare($current_version, self::DB_VERSION, '<')) {
            update_option(self::VERSION_OPTION_KEY, self::DB_VERSION);
            
            // Run version-specific migrations
            self::run_migrations($current_version, self::DB_VERSION);
        }
    }
    
    /**
     * Version-specific data migrations
     */
    private static function run_migrations($from_version, $to_version) {
        // Example: v1.0.0 → v1.1.0 might add new indexes
        if (version_compare($from_version, '1.1.0', '<') && 
            version_compare($to_version, '1.1.0', '>=')) {
            self::migrate_to_1_1_0();
        }
    }
    
    /**
     * Example: Adding new column in v1.1.0
     */
    private static function migrate_to_1_1_0() {
        global $wpdb;
        $table = $wpdb->prefix . 'superforms_triggers';
        
        // Check if column exists
        $column_exists = $wpdb->get_var($wpdb->prepare(
            "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS
            WHERE TABLE_SCHEMA = %s AND TABLE_NAME = %s AND COLUMN_NAME = 'tags'",
            DB_NAME,
            $table
        ));
        
        if (!$column_exists) {
            $wpdb->query("ALTER TABLE {$table} ADD COLUMN tags VARCHAR(500) AFTER description");
            $wpdb->query("ALTER TABLE {$table} ADD KEY tags (tags(191))");
        }
    }
}
```

**Self-Healing Activation:**

```php
// In main plugin file: src/includes/class-triggers.php
add_action('plugins_loaded', array('SUPER_Triggers_Install', 'create_tables'));
```

**Why This Works:**
- `dbDelta()` is idempotent (safe to run repeatedly)
- Runs on every page load (catches FTP uploads, git pulls)
- Version check prevents unnecessary work
- Column existence checks prevent ALTER TABLE errors

---

### 2.2 Handling Schema Changes

**Scenario 1: Adding a Column (v1.1.0)**

```php
// Old schema: No 'tags' column
// New schema: Add tags for trigger organization

// In migrate_to_1_1_0():
$wpdb->query("ALTER TABLE {$wpdb->prefix}superforms_triggers 
              ADD COLUMN tags VARCHAR(500) AFTER description");
$wpdb->query("ALTER TABLE {$wpdb->prefix}superforms_triggers 
              ADD KEY tags (tags(191))");
```

**Scenario 2: Adding an Index (v1.2.0)**

```php
// Performance optimization: Add composite index for logs cleanup

$wpdb->query("ALTER TABLE {$wpdb->prefix}superforms_trigger_logs 
              ADD KEY status_created (execution_status, created_at)");
```

**Scenario 3: Changing Column Type (v2.0.0)**

```php
// Expand action_type from VARCHAR(100) to VARCHAR(200)

$wpdb->query("ALTER TABLE {$wpdb->prefix}superforms_trigger_actions 
              MODIFY COLUMN action_type VARCHAR(200) NOT NULL");
```

**Critical Rules:**
1. Never DROP columns (breaks backwards compatibility)
2. Always check column/index exists before ALTER TABLE
3. Use transactions for multi-step migrations (InnoDB supports this)
4. Log migration errors to debug.log

---

## 3. Data Access Layer (DAL) API Design

### 3.1 DAL Responsibilities

The DAL abstracts database operations and provides:

1. **Type Safety** - Validate input before SQL execution
2. **Consistent Error Handling** - Return `WP_Error` on failure
3. **Query Optimization** - Prevent N+1 queries via bulk methods
4. **Business Logic Separation** - DAL = data operations only (no workflow logic)

**What DAL Does NOT Do:**
- Execute actions (that's the executor's job)
- Validate trigger conditions (that's the conditions engine)
- Send emails or make HTTP requests (that's action handlers)

---

### 3.2 Class: `SUPER_Triggers_DAL`

#### 3.2.1 Trigger CRUD Operations

```php
class SUPER_Triggers_DAL {
    
    /**
     * Create a new trigger
     *
     * @param array $data {
     *     @type string $name           Required. Trigger name
     *     @type string $description    Optional. Human-readable description
     *     @type string $trigger_type   Required. Event type (form_submission, etc.)
     *     @type string $scope          Optional. 'form' or 'global'. Default 'form'
     *     @type int    $form_id        Required if scope='form'. NULL for global
     *     @type array  $conditions     Optional. Conditions engine rules
     *     @type array  $settings       Optional. Trigger-specific config
     *     @type string $status         Optional. 'active', 'paused', 'trash'. Default 'active'
     *     @type int    $priority       Optional. Execution order. Default 10
     *     @type int    $created_by     Optional. User ID
     * }
     * @return int|WP_Error Trigger ID on success, WP_Error on failure
     */
    public static function create_trigger($data) {
        global $wpdb;
        
        // Validate required fields
        $required = array('name', 'trigger_type');
        foreach ($required as $field) {
            if (empty($data[$field])) {
                return new WP_Error(
                    'missing_field',
                    sprintf('Required field missing: %s', $field)
                );
            }
        }
        
        // Validate scope
        $scope = isset($data['scope']) ? $data['scope'] : 'form';
        if (!in_array($scope, array('form', 'global'), true)) {
            return new WP_Error('invalid_scope', 'Scope must be "form" or "global"');
        }
        
        // Validate form_id for form-scoped triggers
        if ($scope === 'form' && empty($data['form_id'])) {
            return new WP_Error('missing_form_id', 'form_id required for form-scoped triggers');
        }
        
        // Prepare insert data
        $insert_data = array(
            'name'        => sanitize_text_field($data['name']),
            'description' => isset($data['description']) ? sanitize_textarea_field($data['description']) : '',
            'trigger_type'=> sanitize_text_field($data['trigger_type']),
            'scope'       => $scope,
            'form_id'     => ($scope === 'form') ? absint($data['form_id']) : null,
            'conditions'  => isset($data['conditions']) ? wp_json_encode($data['conditions']) : null,
            'settings'    => isset($data['settings']) ? wp_json_encode($data['settings']) : null,
            'status'      => isset($data['status']) ? sanitize_text_field($data['status']) : 'active',
            'priority'    => isset($data['priority']) ? absint($data['priority']) : 10,
            'created_by'  => isset($data['created_by']) ? absint($data['created_by']) : null,
            'created_at'  => current_time('mysql'),
            'updated_at'  => current_time('mysql'),
            'fire_count'  => 0,
        );
        
        $format = array('%s', '%s', '%s', '%s', '%d', '%s', '%s', '%s', '%d', '%d', '%s', '%s', '%d');
        
        $result = $wpdb->insert(
            $wpdb->prefix . 'superforms_triggers',
            $insert_data,
            $format
        );
        
        if ($result === false) {
            return new WP_Error('db_insert_failed', $wpdb->last_error);
        }
        
        return $wpdb->insert_id;
    }
    
    /**
     * Update an existing trigger
     *
     * @param int   $trigger_id Trigger ID
     * @param array $data       Fields to update (same structure as create_trigger)
     * @return bool|WP_Error    True on success, WP_Error on failure
     */
    public static function update_trigger($trigger_id, $data) {
        global $wpdb;
        
        $trigger_id = absint($trigger_id);
        if (!$trigger_id) {
            return new WP_Error('invalid_id', 'Invalid trigger ID');
        }
        
        // Check trigger exists
        $exists = $wpdb->get_var($wpdb->prepare(
            "SELECT id FROM {$wpdb->prefix}superforms_triggers WHERE id = %d",
            $trigger_id
        ));
        
        if (!$exists) {
            return new WP_Error('not_found', 'Trigger not found');
        }
        
        // Build update data (only provided fields)
        $update_data = array('updated_at' => current_time('mysql'));
        $format = array('%s');
        
        $allowed_fields = array(
            'name', 'description', 'trigger_type', 'scope', 'form_id',
            'conditions', 'settings', 'status', 'priority'
        );
        
        foreach ($allowed_fields as $field) {
            if (isset($data[$field])) {
                if (in_array($field, array('conditions', 'settings'), true) && is_array($data[$field])) {
                    $update_data[$field] = wp_json_encode($data[$field]);
                    $format[] = '%s';
                } elseif ($field === 'form_id') {
                    $update_data[$field] = ($data[$field] !== null) ? absint($data[$field]) : null;
                    $format[] = '%d';
                } else {
                    $update_data[$field] = sanitize_text_field($data[$field]);
                    $format[] = '%s';
                }
            }
        }
        
        $result = $wpdb->update(
            $wpdb->prefix . 'superforms_triggers',
            $update_data,
            array('id' => $trigger_id),
            $format,
            array('%d')
        );
        
        if ($result === false) {
            return new WP_Error('db_update_failed', $wpdb->last_error);
        }
        
        return true;
    }
    
    /**
     * Soft-delete a trigger (set status = 'trash')
     *
     * @param int $trigger_id Trigger ID
     * @return bool|WP_Error  True on success, WP_Error on failure
     */
    public static function delete_trigger($trigger_id) {
        return self::update_trigger($trigger_id, array('status' => 'trash'));
    }
    
    /**
     * Permanently delete a trigger and its actions
     *
     * @param int $trigger_id Trigger ID
     * @return bool|WP_Error  True on success, WP_Error on failure
     */
    public static function delete_trigger_permanently($trigger_id) {
        global $wpdb;
        
        $trigger_id = absint($trigger_id);
        if (!$trigger_id) {
            return new WP_Error('invalid_id', 'Invalid trigger ID');
        }
        
        // Delete actions first (or rely on CASCADE if using foreign keys)
        $wpdb->delete(
            $wpdb->prefix . 'superforms_trigger_actions',
            array('trigger_id' => $trigger_id),
            array('%d')
        );
        
        // Delete trigger
        $result = $wpdb->delete(
            $wpdb->prefix . 'superforms_triggers',
            array('id' => $trigger_id),
            array('%d')
        );
        
        if ($result === false) {
            return new WP_Error('db_delete_failed', $wpdb->last_error);
        }
        
        return true;
    }
    
    /**
     * Get trigger by ID
     *
     * @param int $trigger_id Trigger ID
     * @return object|null    Trigger object or null if not found
     */
    public static function get_trigger($trigger_id) {
        global $wpdb;
        
        $trigger = $wpdb->get_row($wpdb->prepare(
            "SELECT * FROM {$wpdb->prefix}superforms_triggers WHERE id = %d",
            absint($trigger_id)
        ));
        
        if (!$trigger) {
            return null;
        }
        
        // Decode JSON fields
        $trigger->conditions = !empty($trigger->conditions) ? json_decode($trigger->conditions, true) : null;
        $trigger->settings = !empty($trigger->settings) ? json_decode($trigger->settings, true) : null;
        
        return $trigger;
    }
    
    /**
     * Get triggers by criteria
     *
     * @param array $args {
     *     @type int    $form_id       Filter by form ID
     *     @type string $trigger_type  Filter by trigger type
     *     @type string $status        Filter by status ('active', 'paused', 'trash')
     *     @type string $scope         Filter by scope ('form', 'global')
     *     @type string $orderby       Order by field. Default 'priority'
     *     @type string $order         ASC or DESC. Default 'ASC'
     *     @type int    $limit         Limit results. Default null (no limit)
     * }
     * @return array Array of trigger objects
     */
    public static function get_triggers($args = array()) {
        global $wpdb;
        
        $defaults = array(
            'form_id'      => null,
            'trigger_type' => null,
            'status'       => 'active',
            'scope'        => null,
            'orderby'      => 'priority',
            'order'        => 'ASC',
            'limit'        => null,
        );
        
        $args = wp_parse_args($args, $defaults);
        
        // Build WHERE clause
        $where = array("1=1");
        $prepare_args = array();
        
        if ($args['form_id'] !== null) {
            $where[] = "(form_id = %d OR scope = 'global')";
            $prepare_args[] = absint($args['form_id']);
        }
        
        if ($args['trigger_type'] !== null) {
            $where[] = "trigger_type = %s";
            $prepare_args[] = sanitize_text_field($args['trigger_type']);
        }
        
        if ($args['status'] !== null) {
            $where[] = "status = %s";
            $prepare_args[] = sanitize_text_field($args['status']);
        }
        
        if ($args['scope'] !== null) {
            $where[] = "scope = %s";
            $prepare_args[] = sanitize_text_field($args['scope']);
        }
        
        $where_clause = implode(' AND ', $where);
        
        // Build ORDER BY clause
        $allowed_orderby = array('priority', 'created_at', 'name', 'fire_count');
        $orderby = in_array($args['orderby'], $allowed_orderby, true) ? $args['orderby'] : 'priority';
        $order = strtoupper($args['order']) === 'DESC' ? 'DESC' : 'ASC';
        
        // Build LIMIT clause
        $limit_clause = $args['limit'] ? $wpdb->prepare("LIMIT %d", absint($args['limit'])) : '';
        
        // Execute query
        $query = "SELECT * FROM {$wpdb->prefix}superforms_triggers 
                  WHERE {$where_clause} 
                  ORDER BY {$orderby} {$order} 
                  {$limit_clause}";
        
        if (!empty($prepare_args)) {
            $query = $wpdb->prepare($query, $prepare_args);
        }
        
        $triggers = $wpdb->get_results($query);
        
        // Decode JSON fields
        foreach ($triggers as $trigger) {
            $trigger->conditions = !empty($trigger->conditions) ? json_decode($trigger->conditions, true) : null;
            $trigger->settings = !empty($trigger->settings) ? json_decode($trigger->settings, true) : null;
        }
        
        return $triggers;
    }
    
    /**
     * Increment fire count and update last_fired_at
     *
     * @param int $trigger_id Trigger ID
     * @return bool|WP_Error  True on success, WP_Error on failure
     */
    public static function increment_fire_count($trigger_id) {
        global $wpdb;
        
        $result = $wpdb->query($wpdb->prepare(
            "UPDATE {$wpdb->prefix}superforms_triggers 
             SET fire_count = fire_count + 1,
                 last_fired_at = %s
             WHERE id = %d",
            current_time('mysql'),
            absint($trigger_id)
        ));
        
        if ($result === false) {
            return new WP_Error('db_update_failed', $wpdb->last_error);
        }
        
        return true;
    }
}
```

---

#### 3.2.2 Trigger Action CRUD Operations

```php
/**
 * Create a new trigger action
 *
 * @param array $data {
 *     @type int    $trigger_id       Required. Parent trigger ID
 *     @type string $action_type      Required. Action type identifier
 *     @type array  $action_config    Required. Action configuration
 *     @type int    $execution_order  Optional. Order within trigger. Default 0
 *     @type string $status           Optional. 'active', 'paused', 'trash'. Default 'active'
 *     @type bool   $retry_on_failure Optional. Enable retries. Default false
 *     @type int    $max_retries      Optional. Max retry attempts. Default 3
 * }
 * @return int|WP_Error Action ID on success, WP_Error on failure
 */
public static function create_trigger_action($data) {
    global $wpdb;
    
    // Validate required fields
    $required = array('trigger_id', 'action_type', 'action_config');
    foreach ($required as $field) {
        if (!isset($data[$field])) {
            return new WP_Error('missing_field', sprintf('Required field missing: %s', $field));
        }
    }
    
    // Validate trigger exists
    $trigger_exists = $wpdb->get_var($wpdb->prepare(
        "SELECT id FROM {$wpdb->prefix}superforms_triggers WHERE id = %d",
        absint($data['trigger_id'])
    ));
    
    if (!$trigger_exists) {
        return new WP_Error('invalid_trigger', 'Parent trigger does not exist');
    }
    
    // Prepare insert data
    $insert_data = array(
        'trigger_id'       => absint($data['trigger_id']),
        'action_type'      => sanitize_text_field($data['action_type']),
        'action_config'    => wp_json_encode($data['action_config']),
        'execution_order'  => isset($data['execution_order']) ? absint($data['execution_order']) : 0,
        'status'           => isset($data['status']) ? sanitize_text_field($data['status']) : 'active',
        'retry_on_failure' => !empty($data['retry_on_failure']) ? 1 : 0,
        'max_retries'      => isset($data['max_retries']) ? absint($data['max_retries']) : 3,
        'created_at'       => current_time('mysql'),
        'updated_at'       => current_time('mysql'),
    );
    
    $format = array('%d', '%s', '%s', '%d', '%s', '%d', '%d', '%s', '%s');
    
    $result = $wpdb->insert(
        $wpdb->prefix . 'superforms_trigger_actions',
        $insert_data,
        $format
    );
    
    if ($result === false) {
        return new WP_Error('db_insert_failed', $wpdb->last_error);
    }
    
    return $wpdb->insert_id;
}

/**
 * Update an existing trigger action
 *
 * @param int   $action_id Action ID
 * @param array $data      Fields to update
 * @return bool|WP_Error   True on success, WP_Error on failure
 */
public static function update_trigger_action($action_id, $data) {
    global $wpdb;
    
    $action_id = absint($action_id);
    if (!$action_id) {
        return new WP_Error('invalid_id', 'Invalid action ID');
    }
    
    // Check action exists
    $exists = $wpdb->get_var($wpdb->prepare(
        "SELECT id FROM {$wpdb->prefix}superforms_trigger_actions WHERE id = %d",
        $action_id
    ));
    
    if (!$exists) {
        return new WP_Error('not_found', 'Action not found');
    }
    
    // Build update data
    $update_data = array('updated_at' => current_time('mysql'));
    $format = array('%s');
    
    $allowed_fields = array(
        'action_type', 'action_config', 'execution_order', 
        'status', 'retry_on_failure', 'max_retries'
    );
    
    foreach ($allowed_fields as $field) {
        if (isset($data[$field])) {
            if ($field === 'action_config' && is_array($data[$field])) {
                $update_data[$field] = wp_json_encode($data[$field]);
                $format[] = '%s';
            } elseif (in_array($field, array('execution_order', 'retry_on_failure', 'max_retries'), true)) {
                $update_data[$field] = absint($data[$field]);
                $format[] = '%d';
            } else {
                $update_data[$field] = sanitize_text_field($data[$field]);
                $format[] = '%s';
            }
        }
    }
    
    $result = $wpdb->update(
        $wpdb->prefix . 'superforms_trigger_actions',
        $update_data,
        array('id' => $action_id),
        $format,
        array('%d')
    );
    
    if ($result === false) {
        return new WP_Error('db_update_failed', $wpdb->last_error);
    }
    
    return true;
}

/**
 * Delete a trigger action (soft delete)
 *
 * @param int $action_id Action ID
 * @return bool|WP_Error True on success, WP_Error on failure
 */
public static function delete_trigger_action($action_id) {
    return self::update_trigger_action($action_id, array('status' => 'trash'));
}

/**
 * Get actions for a trigger
 *
 * @param int   $trigger_id Trigger ID
 * @param array $args {
 *     @type string $status  Filter by status. Default 'active'
 *     @type bool   $orderby Order by execution_order. Default true
 * }
 * @return array Array of action objects
 */
public static function get_trigger_actions($trigger_id, $args = array()) {
    global $wpdb;
    
    $defaults = array(
        'status' => 'active',
        'orderby' => true,
    );
    
    $args = wp_parse_args($args, $defaults);
    
    $where = $wpdb->prepare("trigger_id = %d", absint($trigger_id));
    
    if ($args['status'] !== null) {
        $where .= $wpdb->prepare(" AND status = %s", sanitize_text_field($args['status']));
    }
    
    $order_clause = $args['orderby'] ? "ORDER BY execution_order ASC" : "";
    
    $actions = $wpdb->get_results(
        "SELECT * FROM {$wpdb->prefix}superforms_trigger_actions 
         WHERE {$where} 
         {$order_clause}"
    );
    
    // Decode JSON config
    foreach ($actions as $action) {
        $action->action_config = json_decode($action->action_config, true);
    }
    
    return $actions;
}

/**
 * Bulk update action execution order
 *
 * @param array $order_map [ action_id => new_order, ... ]
 * @return bool|WP_Error   True on success, WP_Error on failure
 */
public static function reorder_trigger_actions($order_map) {
    global $wpdb;
    
    // Use transaction for atomicity
    $wpdb->query('START TRANSACTION');
    
    try {
        foreach ($order_map as $action_id => $new_order) {
            $result = $wpdb->update(
                $wpdb->prefix . 'superforms_trigger_actions',
                array('execution_order' => absint($new_order)),
                array('id' => absint($action_id)),
                array('%d'),
                array('%d')
            );
            
            if ($result === false) {
                throw new Exception('Failed to update action order');
            }
        }
        
        $wpdb->query('COMMIT');
        return true;
        
    } catch (Exception $e) {
        $wpdb->query('ROLLBACK');
        return new WP_Error('reorder_failed', $e->getMessage());
    }
}
```

---

#### 3.2.3 Trigger Log Operations

```php
/**
 * Create a log entry
 *
 * @param array $data {
 *     @type int    $trigger_id         Required. Trigger ID
 *     @type int    $action_id          Optional. Action ID (null for trigger-level logs)
 *     @type int    $entry_id           Optional. Contact entry ID
 *     @type int    $form_id            Required. Form ID
 *     @type string $event_type         Required. Event type
 *     @type string $execution_status   Required. 'success', 'failure', 'retry', 'skipped'
 *     @type array  $execution_data     Optional. Entry data snapshot
 *     @type string $error_message      Optional. Error details
 *     @type string $stack_trace        Optional. PHP stack trace
 *     @type int    $execution_time_ms  Optional. Execution time in milliseconds
 *     @type float  $memory_usage_mb    Optional. Peak memory in MB
 *     @type int    $retry_attempt      Optional. Retry count. Default 0
 * }
 * @return int|WP_Error Log ID on success, WP_Error on failure
 */
public static function create_log($data) {
    global $wpdb;
    
    // Validate required fields
    $required = array('trigger_id', 'form_id', 'event_type', 'execution_status');
    foreach ($required as $field) {
        if (!isset($data[$field])) {
            return new WP_Error('missing_field', sprintf('Required field missing: %s', $field));
        }
    }
    
    // Prepare insert data
    $insert_data = array(
        'trigger_id'        => absint($data['trigger_id']),
        'action_id'         => isset($data['action_id']) ? absint($data['action_id']) : null,
        'entry_id'          => isset($data['entry_id']) ? absint($data['entry_id']) : null,
        'form_id'           => absint($data['form_id']),
        'event_type'        => sanitize_text_field($data['event_type']),
        'execution_status'  => sanitize_text_field($data['execution_status']),
        'execution_data'    => isset($data['execution_data']) ? wp_json_encode($data['execution_data']) : null,
        'error_message'     => isset($data['error_message']) ? sanitize_textarea_field($data['error_message']) : null,
        'stack_trace'       => isset($data['stack_trace']) ? $data['stack_trace'] : null, // Don't sanitize (formatting)
        'execution_time_ms' => isset($data['execution_time_ms']) ? absint($data['execution_time_ms']) : null,
        'memory_usage_mb'   => isset($data['memory_usage_mb']) ? floatval($data['memory_usage_mb']) : null,
        'retry_attempt'     => isset($data['retry_attempt']) ? absint($data['retry_attempt']) : 0,
        'created_at'        => current_time('mysql'),
    );
    
    $format = array('%d', '%d', '%d', '%d', '%s', '%s', '%s', '%s', '%s', '%d', '%f', '%d', '%s');
    
    $result = $wpdb->insert(
        $wpdb->prefix . 'superforms_trigger_logs',
        $insert_data,
        $format
    );
    
    if ($result === false) {
        return new WP_Error('db_insert_failed', $wpdb->last_error);
    }
    
    return $wpdb->insert_id;
}

/**
 * Get logs by criteria
 *
 * @param array $args {
 *     @type int    $trigger_id       Filter by trigger ID
 *     @type int    $action_id        Filter by action ID
 *     @type int    $entry_id         Filter by entry ID
 *     @type int    $form_id          Filter by form ID
 *     @type string $execution_status Filter by status
 *     @type string $date_from        Start date (Y-m-d H:i:s)
 *     @type string $date_to          End date (Y-m-d H:i:s)
 *     @type int    $limit            Limit results. Default 100
 *     @type int    $offset           Offset. Default 0
 *     @type string $orderby          Order by field. Default 'created_at'
 *     @type string $order            ASC or DESC. Default 'DESC'
 * }
 * @return array Array of log objects
 */
public static function get_logs($args = array()) {
    global $wpdb;
    
    $defaults = array(
        'trigger_id'       => null,
        'action_id'        => null,
        'entry_id'         => null,
        'form_id'          => null,
        'execution_status' => null,
        'date_from'        => null,
        'date_to'          => null,
        'limit'            => 100,
        'offset'           => 0,
        'orderby'          => 'created_at',
        'order'            => 'DESC',
    );
    
    $args = wp_parse_args($args, $defaults);
    
    // Build WHERE clause
    $where = array("1=1");
    $prepare_args = array();
    
    if ($args['trigger_id'] !== null) {
        $where[] = "trigger_id = %d";
        $prepare_args[] = absint($args['trigger_id']);
    }
    
    if ($args['action_id'] !== null) {
        $where[] = "action_id = %d";
        $prepare_args[] = absint($args['action_id']);
    }
    
    if ($args['entry_id'] !== null) {
        $where[] = "entry_id = %d";
        $prepare_args[] = absint($args['entry_id']);
    }
    
    if ($args['form_id'] !== null) {
        $where[] = "form_id = %d";
        $prepare_args[] = absint($args['form_id']);
    }
    
    if ($args['execution_status'] !== null) {
        $where[] = "execution_status = %s";
        $prepare_args[] = sanitize_text_field($args['execution_status']);
    }
    
    if ($args['date_from'] !== null) {
        $where[] = "created_at >= %s";
        $prepare_args[] = sanitize_text_field($args['date_from']);
    }
    
    if ($args['date_to'] !== null) {
        $where[] = "created_at <= %s";
        $prepare_args[] = sanitize_text_field($args['date_to']);
    }
    
    $where_clause = implode(' AND ', $where);
    
    // Build ORDER BY
    $allowed_orderby = array('created_at', 'execution_time_ms', 'memory_usage_mb');
    $orderby = in_array($args['orderby'], $allowed_orderby, true) ? $args['orderby'] : 'created_at';
    $order = strtoupper($args['order']) === 'ASC' ? 'ASC' : 'DESC';
    
    // Build LIMIT/OFFSET
    $prepare_args[] = absint($args['limit']);
    $prepare_args[] = absint($args['offset']);
    
    // Execute query
    $query = "SELECT * FROM {$wpdb->prefix}superforms_trigger_logs 
              WHERE {$where_clause} 
              ORDER BY {$orderby} {$order} 
              LIMIT %d OFFSET %d";
    
    $query = $wpdb->prepare($query, $prepare_args);
    $logs = $wpdb->get_results($query);
    
    // Decode JSON execution_data
    foreach ($logs as $log) {
        $log->execution_data = !empty($log->execution_data) ? json_decode($log->execution_data, true) : null;
    }
    
    return $logs;
}

/**
 * Get log statistics for a trigger
 *
 * @param int    $trigger_id Trigger ID
 * @param string $date_from  Optional. Start date
 * @param string $date_to    Optional. End date
 * @return array Statistics {
 *     @type int   $total_executions Total log entries
 *     @type int   $success_count    Successful executions
 *     @type int   $failure_count    Failed executions
 *     @type float $success_rate     Success percentage
 *     @type float $avg_time_ms      Average execution time
 *     @type float $max_time_ms      Maximum execution time
 * }
 */
public static function get_trigger_stats($trigger_id, $date_from = null, $date_to = null) {
    global $wpdb;
    
    $where = $wpdb->prepare("trigger_id = %d", absint($trigger_id));
    
    if ($date_from !== null) {
        $where .= $wpdb->prepare(" AND created_at >= %s", sanitize_text_field($date_from));
    }
    
    if ($date_to !== null) {
        $where .= $wpdb->prepare(" AND created_at <= %s", sanitize_text_field($date_to));
    }
    
    $stats = $wpdb->get_row("
        SELECT 
            COUNT(*) as total_executions,
            SUM(CASE WHEN execution_status = 'success' THEN 1 ELSE 0 END) as success_count,
            SUM(CASE WHEN execution_status = 'failure' THEN 1 ELSE 0 END) as failure_count,
            AVG(execution_time_ms) as avg_time_ms,
            MAX(execution_time_ms) as max_time_ms
        FROM {$wpdb->prefix}superforms_trigger_logs
        WHERE {$where}
    ", ARRAY_A);
    
    // Calculate success rate
    $stats['success_rate'] = $stats['total_executions'] > 0
        ? ($stats['success_count'] / $stats['total_executions']) * 100
        : 0;
    
    return $stats;
}

/**
 * Delete logs older than specified date
 *
 * @param string $date_before Delete logs before this date (Y-m-d H:i:s)
 * @param int    $batch_size  Process in batches. Default 1000
 * @return int|WP_Error       Number of deleted rows, or WP_Error on failure
 */
public static function delete_old_logs($date_before, $batch_size = 1000) {
    global $wpdb;
    
    $total_deleted = 0;
    
    while (true) {
        $result = $wpdb->query($wpdb->prepare(
            "DELETE FROM {$wpdb->prefix}superforms_trigger_logs 
             WHERE created_at < %s 
             LIMIT %d",
            sanitize_text_field($date_before),
            absint($batch_size)
        ));
        
        if ($result === false) {
            return new WP_Error('delete_failed', $wpdb->last_error);
        }
        
        $total_deleted += $result;
        
        // Stop if no more rows to delete
        if ($result < $batch_size) {
            break;
        }
        
        // Prevent timeout on large datasets
        usleep(100000); // 100ms pause between batches
    }
    
    return $total_deleted;
}
```

---

### 3.3 DAL Usage Examples

#### Example 1: Creating a Form Submission Trigger

```php
// Create trigger
$trigger_id = SUPER_Triggers_DAL::create_trigger(array(
    'name'         => 'Send Admin Notification',
    'description'  => 'Email admin when contact form submitted',
    'trigger_type' => 'form_submission',
    'scope'        => 'form',
    'form_id'      => 123,
    'conditions'   => array(
        'all' => array(
            array('field' => 'email', 'operator' => 'is_not_empty'),
        ),
    ),
    'status'       => 'active',
    'priority'     => 10,
    'created_by'   => get_current_user_id(),
));

if (is_wp_error($trigger_id)) {
    wp_die($trigger_id->get_error_message());
}

// Add email action
$action_id = SUPER_Triggers_DAL::create_trigger_action(array(
    'trigger_id'      => $trigger_id,
    'action_type'     => 'send_email',
    'action_config'   => array(
        'to'       => 'admin@example.com',
        'subject'  => 'New form submission',
        'template' => 'admin_notification',
    ),
    'execution_order' => 0,
    'retry_on_failure'=> true,
    'max_retries'     => 3,
));
```

#### Example 2: Fetching Active Triggers for Form

```php
// Get all active triggers for form 123 (including global triggers)
$triggers = SUPER_Triggers_DAL::get_triggers(array(
    'form_id'      => 123,
    'trigger_type' => 'form_submission',
    'status'       => 'active',
    'orderby'      => 'priority',
    'order'        => 'ASC',
));

foreach ($triggers as $trigger) {
    // Get actions for this trigger
    $actions = SUPER_Triggers_DAL::get_trigger_actions($trigger->id);
    
    // Execute trigger logic...
}
```

#### Example 3: Logging Execution

```php
// Log successful execution
$log_id = SUPER_Triggers_DAL::create_log(array(
    'trigger_id'        => 42,
    'action_id'         => 15,
    'entry_id'          => 789,
    'form_id'           => 123,
    'event_type'        => 'form_submission',
    'execution_status'  => 'success',
    'execution_data'    => $entry_data, // Snapshot
    'execution_time_ms' => 450,
    'memory_usage_mb'   => 2.5,
));

// Log failed execution
$log_id = SUPER_Triggers_DAL::create_log(array(
    'trigger_id'       => 42,
    'action_id'        => 15,
    'entry_id'         => 789,
    'form_id'          => 123,
    'event_type'       => 'form_submission',
    'execution_status' => 'failure',
    'error_message'    => 'SMTP connection failed',
    'stack_trace'      => $exception->getTraceAsString(),
    'retry_attempt'    => 1,
));
```

#### Example 4: Performance Dashboard

```php
// Get statistics for trigger
$stats = SUPER_Triggers_DAL::get_trigger_stats(
    42, // trigger_id
    date('Y-m-d H:i:s', strtotime('-30 days')), // last 30 days
    date('Y-m-d H:i:s')
);

echo "Success Rate: " . round($stats['success_rate'], 2) . "%\n";
echo "Average Time: " . round($stats['avg_time_ms']) . "ms\n";
echo "Total Executions: " . $stats['total_executions'] . "\n";
```

---

## 4. Key Architectural Considerations

### 4.1 Scope Handling: Form-Specific vs Global

**Implementation Strategy:**

```sql
-- Query: Get all triggers for form 123 (including global)
SELECT * FROM wp_superforms_triggers
WHERE (form_id = 123 OR scope = 'global')
  AND status = 'active'
  AND trigger_type = 'form_submission'
ORDER BY priority ASC;
```

**Why This Works:**
- Global triggers apply to ALL forms (`form_id = NULL`, `scope = 'global'`)
- Form-specific triggers apply to ONE form (`form_id = 123`, `scope = 'form'`)
- Single query retrieves both types efficiently via `scope_form` composite index

**Alternative Rejected:**
- Polymorphic association (scope = 'form'/'product'/'user') → Complex, unnecessary
- Separate global_triggers table → Duplicates schema, complicates queries

---

### 4.2 Soft Deletion Strategy

**WordPress-Native Approach:**

```php
// Soft delete (reversible)
SUPER_Triggers_DAL::delete_trigger(42); // Sets status = 'trash'

// Restore from trash
SUPER_Triggers_DAL::update_trigger(42, array('status' => 'active'));

// Permanent deletion (irreversible)
SUPER_Triggers_DAL::delete_trigger_permanently(42); // Removes row + actions
```

**Benefits:**
- Consistent with WordPress `post_status` system
- No additional `deleted_at` timestamp column needed
- Users familiar with WordPress trash workflow

**Trade-off:**
- Logs do NOT use soft deletion (immutable audit trail)
- Use time-based cleanup instead: `delete_old_logs(date('Y-m-d H:i:s', strtotime('-90 days')))`

---

### 4.3 JSON Column Strategy

**When to Use JSON:**

| Data Type | Storage Method | Reasoning |
|-----------|----------------|-----------|
| Trigger conditions | JSON (`LONGTEXT`) | Variable schema, validated by conditions engine |
| Action config | JSON (`LONGTEXT`) | Different actions = different config structures |
| Execution snapshot | JSON (`LONGTEXT`) | Entry data varies by form schema |
| Execution status | VARCHAR(20) | Fixed values, needs indexing |

**JSON Validation Pattern:**

```php
// Before storing conditions
$validation_result = SUPER_Conditions_Engine::validate_rules($data['conditions']);
if (is_wp_error($validation_result)) {
    return $validation_result;
}

// Store validated JSON
$data['conditions'] = wp_json_encode($data['conditions']);
```

---

### 4.4 Performance Optimization

**1. Composite Index Usage**

```sql
-- ✅ GOOD: Uses form_type_status index
SELECT * FROM wp_superforms_triggers
WHERE form_id = 123
  AND trigger_type = 'form_submission'
  AND status = 'active';

-- ⚠️ SUBOPTIMAL: Only uses form_id index (partial)
SELECT * FROM wp_superforms_triggers
WHERE form_id = 123
  AND priority = 10;
```

**2. Bulk Operations**

```php
// ❌ BAD: N+1 query problem
foreach ($trigger_ids as $id) {
    $trigger = SUPER_Triggers_DAL::get_trigger($id);
    // Process...
}

// ✅ GOOD: Single bulk query
$triggers = $wpdb->get_results($wpdb->prepare(
    "SELECT * FROM {$wpdb->prefix}superforms_triggers 
     WHERE id IN (" . implode(',', array_fill(0, count($ids), '%d')) . ")",
    ...$ids
));
```

**3. Log Cleanup as Action Scheduler Job**

```php
// Register recurring cleanup job
if (!as_next_scheduled_action('superforms_cleanup_trigger_logs')) {
    as_schedule_recurring_action(
        strtotime('+1 day 2:00am'),
        DAY_IN_SECONDS,
        'superforms_cleanup_trigger_logs'
    );
}

// Cleanup handler
add_action('superforms_cleanup_trigger_logs', function() {
    $cutoff_date = date('Y-m-d H:i:s', strtotime('-90 days'));
    SUPER_Triggers_DAL::delete_old_logs($cutoff_date, 1000);
});
```

---

## 5. Testing Considerations

### 5.1 Database Schema Tests

```php
class SUPER_Triggers_Schema_Test extends WP_UnitTestCase {
    
    public function test_tables_exist() {
        global $wpdb;
        
        $tables = array(
            $wpdb->prefix . 'superforms_triggers',
            $wpdb->prefix . 'superforms_trigger_actions',
            $wpdb->prefix . 'superforms_trigger_logs',
        );
        
        foreach ($tables as $table) {
            $exists = $wpdb->get_var($wpdb->prepare('SHOW TABLES LIKE %s', $table));
            $this->assertEquals($table, $exists, "Table {$table} should exist");
        }
    }
    
    public function test_indexes_exist() {
        global $wpdb;
        
        $indexes = $wpdb->get_results("
            SHOW INDEX FROM {$wpdb->prefix}superforms_triggers
            WHERE Key_name = 'form_type_status'
        ");
        
        $this->assertNotEmpty($indexes, 'Composite index form_type_status should exist');
        $this->assertCount(3, $indexes, 'Index should cover 3 columns');
    }
}
```

### 5.2 DAL Method Tests

```php
class SUPER_Triggers_DAL_Test extends WP_UnitTestCase {
    
    public function test_create_trigger_validates_required_fields() {
        $result = SUPER_Triggers_DAL::create_trigger(array(
            'name' => 'Test Trigger',
            // Missing trigger_type
        ));
        
        $this->assertWPError($result);
        $this->assertEquals('missing_field', $result->get_error_code());
    }
    
    public function test_create_trigger_validates_scope() {
        $result = SUPER_Triggers_DAL::create_trigger(array(
            'name'         => 'Test Trigger',
            'trigger_type' => 'form_submission',
            'scope'        => 'invalid_scope',
        ));
        
        $this->assertWPError($result);
        $this->assertEquals('invalid_scope', $result->get_error_code());
    }
    
    public function test_get_triggers_includes_global_and_form_specific() {
        // Create global trigger
        $global_id = SUPER_Triggers_DAL::create_trigger(array(
            'name'         => 'Global Trigger',
            'trigger_type' => 'form_submission',
            'scope'        => 'global',
        ));
        
        // Create form-specific trigger
        $form_id = SUPER_Triggers_DAL::create_trigger(array(
            'name'         => 'Form Trigger',
            'trigger_type' => 'form_submission',
            'scope'        => 'form',
            'form_id'      => 123,
        ));
        
        // Query for form 123
        $triggers = SUPER_Triggers_DAL::get_triggers(array(
            'form_id'      => 123,
            'trigger_type' => 'form_submission',
        ));
        
        $this->assertCount(2, $triggers, 'Should return both global and form-specific');
    }
}
```

---

## 6. Summary & Implementation Roadmap

### 6.1 Schema Summary

| Table | Purpose | Soft Delete | Key Indexes |
|-------|---------|-------------|-------------|
| `superforms_triggers` | Trigger definitions | ✅ `status` column | `form_type_status`, `scope_form` |
| `superforms_trigger_actions` | Actions per trigger | ✅ `status` column | `trigger_order`, `trigger_status` |
| `superforms_trigger_logs` | Execution history | ❌ Time-based cleanup | `trigger_status_date`, `created_at` |

### 6.2 DAL Method Summary

| Operation | Method | Return Type |
|-----------|--------|-------------|
| Create trigger | `create_trigger($data)` | `int|WP_Error` |
| Update trigger | `update_trigger($id, $data)` | `bool|WP_Error` |
| Delete trigger | `delete_trigger($id)` | `bool|WP_Error` |
| Get trigger | `get_trigger($id)` | `object|null` |
| Get triggers | `get_triggers($args)` | `array` |
| Increment fire count | `increment_fire_count($id)` | `bool|WP_Error` |
| Create action | `create_trigger_action($data)` | `int|WP_Error` |
| Update action | `update_trigger_action($id, $data)` | `bool|WP_Error` |
| Get actions | `get_trigger_actions($trigger_id)` | `array` |
| Reorder actions | `reorder_trigger_actions($map)` | `bool|WP_Error` |
| Create log | `create_log($data)` | `int|WP_Error` |
| Get logs | `get_logs($args)` | `array` |
| Get stats | `get_trigger_stats($id, $from, $to)` | `array` |
| Delete old logs | `delete_old_logs($date, $batch)` | `int|WP_Error` |

### 6.3 Implementation Checklist

**Phase 1: Schema Setup**
- [ ] Create `SUPER_Triggers_Install` class
- [ ] Define `create_tables()` with dbDelta SQL
- [ ] Hook into `plugins_loaded` for self-healing
- [ ] Add version tracking to `wp_options`
- [ ] Write schema tests (tables exist, indexes valid)

**Phase 2: DAL Implementation**
- [ ] Create `SUPER_Triggers_DAL` class
- [ ] Implement trigger CRUD methods
- [ ] Implement action CRUD methods
- [ ] Implement log operations
- [ ] Write unit tests for all methods

**Phase 3: Migration & Validation**
- [ ] Add version comparison logic
- [ ] Implement `run_migrations()` framework
- [ ] Test upgrade from v1.0.0 → v1.1.0
- [ ] Verify foreign key constraints (if using)
- [ ] Test rollback scenarios

**Phase 4: Performance & Monitoring**
- [ ] Register Action Scheduler cleanup job
- [ ] Add performance logging (execution time, memory)
- [ ] Create stats dashboard queries
- [ ] Optimize slow queries (EXPLAIN analysis)
- [ ] Document query patterns

---

## 7. Open Questions for Review

1. **Foreign Key Constraints**: Should we enforce CASCADE deletion via foreign keys, or handle orphaned records in application code?
   - **Recommendation**: Use foreign keys for triggers→actions (data integrity), but NOT for logs (preserve audit trail)

2. **Log Retention Policy**: Is 90 days the right default? Should it be configurable per form?
   - **Recommendation**: Make it configurable via settings, default 90 days

3. **Execution Data Snapshot Size**: Should we limit the size of `execution_data` JSON (e.g., max 64KB)?
   - **Recommendation**: Add validation in `create_log()` to truncate large payloads

4. **Global Triggers Priority**: Should global triggers always run before/after form-specific triggers?
   - **Recommendation**: Use same priority system (admin can set priority for both types)

5. **Multisite Considerations**: Should triggers be network-wide or per-site?
   - **Recommendation**: Per-site (consistent with forms being site-specific), revisit if network-wide triggers needed

---

This proposal provides a **production-ready foundation** for the triggers/actions system, following Super Forms' established patterns while introducing modern extensibility. The schema supports all core requirements (scopes, soft deletion, execution logging) while maintaining performance through strategic indexing. The DAL provides a clean API that separates data operations from business logic, enabling testable, maintainable code.
